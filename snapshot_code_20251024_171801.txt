SNAPSHOT OF CODE - 20251024_171801
Project: D:\Clientes Agentes\OD Drive\Campanha CHECK\app_oficial_odrive


=== FILE: backend\lib\campaignImport.js ===

import { nanoid } from 'nanoid';
import { STATUS, normalizeStatus, normalizeName } from './normalize.js';

export function createStatusCounter() {
  return STATUS.reduce((acc, status) => {
    acc[status] = 0;
    return acc;
  }, {});
}

export function resolveSheetName(name, fallback) {
  const base = (name || fallback || '').trim();
  if (!base) return fallback || '';
  const lower = base.toLowerCase();
  if (lower === 'pagina1' || lower === 'p\u00E1gina1') return 'P\u00E1gina1';
  return base;
}

export function buildDriversFromRows(rows, { campaignId, now, previousDrivers = [] }) {
  const result = {
    drivers: [],
    counts: createStatusCounter(),
    imported: 0,
    review: 0,
    reviewEntries: [],
  };

  const previousMap = new Map(
    previousDrivers.map(driver => [
      driver.nameKey || normalizeName(driver.name),
      driver,
    ]),
  );

  rows.forEach((row, index) => {
    const name =
      row['Nome'] ||
      row['NOME'] ||
      row['name'] ||
      row['nome'] ||
      row['Motorista'] ||
      '';

    if (!name) return;

    const nameKey = normalizeName(name);
    const previous = previousMap.get(nameKey);

    const rowNumber =
      row.__rowNumber ||
      previous?.rowNumber ||
      index + 2; // inclui cabecalho
    const raw = { ...row };
    delete raw.__rowNumber;

    const city = row['Cidade'] || row['CIDADE'] || row['cidade'] || '';
    const pix = row['PIX'] || row['Pix'] || row['pix'] || '';
    const statusRaw = row['Status'] || row['STATUS'] || row['status'] || '';
    const status = normalizeStatus(statusRaw);

    const driverId = previous?.id || nanoid();

    const driver = {
      id: driverId,
      campaignId,
      name,
      nameKey,
      city,
      pix,
      status,
      statusRaw,
      rowNumber,
      raw,
      createdAt: previous?.createdAt || now,
      updatedAt: now,
    };

    if (previous?.km) driver.km = previous.km;
    if (previous?.adh) driver.adh = previous.adh;
    if (previous?._CPF_HASH) driver._CPF_HASH = previous._CPF_HASH;
    if (previous?._InviteLink) driver._InviteLink = previous._InviteLink;

    result.drivers.push(driver);
    result.counts[status] = (result.counts[status] || 0) + 1;

    if (status === 'revisar') {
      result.review += 1;
      result.reviewEntries.push({
        id: nanoid(),
        type: 'STATUS_INVALIDO',
        campaignId,
        driverId,
        driverName: name,
        column: 'Status',
        value: statusRaw || '',
        rowNumber,
        createdAt: now,
        note: statusRaw
          ? `Status "${statusRaw}" fora do padrao`
          : 'Status vazio ou invalido',
      });
    } else {
      result.imported += 1;
    }

    previousMap.delete(nameKey);
  });

  result.review = result.reviewEntries.length;
  return result;
}



=== FILE: backend\lib\match.js ===


=== FILE: backend\lib\normalize.js ===

export const STATUS = ['agendado','confirmado','instalado','aguardando','cadastrando','problema','revisar'];

export function normalizeStatus(s) {
  const v = String(s || '').trim().toLowerCase();
  const map = {
    'agendada':'agendado','confirmada':'confirmado','instalada':'instalado',
    'pendente':'aguardando','em cadastro':'cadastrando',
  };
  const cand = map[v] || v;
  return STATUS.includes(cand) ? cand : 'revisar';
}

export function normalizeName(n) {
  return String(n || '')
    .normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .replace(/\s+/g,' ').trim().toLowerCase();
}


=== FILE: backend\lib\report.js ===


=== FILE: backend\routes\campaigns.js ===

import { Router } from 'express';
import fs from 'fs';
import { nanoid } from 'nanoid';
import { STATUS, normalizeStatus, normalizeName } from '../lib/normalize.js';
import { buildDriversFromRows, resolveSheetName } from '../lib/campaignImport.js';
import {
  readSheetByRange,
  readSheetHeader,
  appendSheetRow,
  deleteSheetRow,
  getSheetId,
  updateSheetRow,
} from '../services/sheets.js';

const DB_PATH = new URL('../data/db.json', import.meta.url);
const router = Router();
const CAMPAIGN_STATUS = ['ativa', 'pausada', 'encerrada', 'inativa'];

function loadDB() {
  try {
    return JSON.parse(fs.readFileSync(DB_PATH));
  } catch {
    return { campaigns: [], drivers: [], review: [] };
  }
}

function saveDB(db) {
  fs.writeFileSync(DB_PATH, JSON.stringify(db, null, 2));
}

function summarizeCampaign(db, campaign) {
  const drivers = db.drivers.filter(d => d.campaignId === campaign.id);
  const reviewItems = db.review.filter(r => r.campaignId === campaign.id);

  const counts = drivers.reduce((acc, driver) => {
    const key = driver.status || 'revisar';
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});

  for (const status of STATUS) {
    if (!counts[status]) counts[status] = 0;
  }

  return {
    ...campaign,
    counts,
    driverCount: drivers.length,
    reviewCount: reviewItems.length,
    updatedAt: campaign.updatedAt || campaign.createdAt || Date.now(),
    sheetHeader: Array.isArray(campaign.sheetHeader)
      ? [...campaign.sheetHeader]
      : [],
    sheetGid: campaign.sheetGid ?? null,
  };
}

function ensureSheetConfig(campaign) {
  if (!campaign.sheetId) {
    throw Object.assign(new Error('Campanha nao possui sheetId configurado'), {
      status: 400,
    });
  }
  const sheetName = resolveSheetName(campaign.sheetName, 'Pagina1');
  campaign.sheetName = sheetName;
  return { sheetId: campaign.sheetId, sheetName };
}

function extractRowNumber(range) {
  if (!range) return 0;
  const [, segment = ''] = range.split('!');
  const match = segment.match(/([0-9]+)(?::[A-Z]*([0-9]+))?$/i);
  if (!match) return 0;
  const [, start, end] = match;
  return parseInt(end || start, 10);
}

router.use((req, res, next) => {
  if (process.env.DEBUG_ROUTES === '1') {
    console.log(`[campaigns] ${req.method} ${req.originalUrl}`);
  }
  next();
});

router.get('/', (req, res) => {
  const db = loadDB();
  const summaries = db.campaigns.map(c => summarizeCampaign(db, c));
  res.json(summaries);
});

router.get('/:id', (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });
  const payload = summarizeCampaign(db, campaign);
  payload.drivers = db.drivers.filter(d => d.campaignId === campaign.id);
  payload.review = db.review.filter(r => r.campaignId === campaign.id);
  res.json(payload);
});

router.post('/', (req, res) => {
  const { name, client, period } = req.body;
  if (!name) return res.status(400).json({ error: 'Nome obrigatorio' });

  const db = loadDB();
  const id = nanoid();
  const now = Date.now();

  db.campaigns.push({
    id,
    name,
    client: client || '',
    period: period || '',
    status: 'ativa',
    sheetId: null,
    sheetName: null,
    driveFolderId: null,
    createdAt: now,
    updatedAt: now,
  });

  saveDB(db);
  res.status(201).json({ id });
});

router.post('/:id/sync', async (req, res) => {
  const { sheetId: overrideSheetId, sheetName, name, client, period } = req.body || {};
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const sheetId = (overrideSheetId || campaign.sheetId || '').trim();
  if (!sheetId) {
    return res.status(400).json({ error: 'Campanha nao possui sheetId configurado' });
  }

  const resolvedSheetName = resolveSheetName(
    sheetName || campaign.sheetName || 'Pagina1',
    'Pagina1',
  );

  const rows = await readSheetByRange(sheetId, `${resolvedSheetName}!A:Z`);
  const header = await readSheetHeader(sheetId, resolvedSheetName);
  const sheetGid = await getSheetId(sheetId, resolvedSheetName);
  const now = Date.now();

  const previousDrivers = db.drivers.filter(d => d.campaignId === campaign.id);
  const { drivers, counts, imported, reviewEntries } = buildDriversFromRows(rows, {
    campaignId: campaign.id,
    now,
    previousDrivers,
  });

  db.drivers = db.drivers.filter(d => d.campaignId !== campaign.id);
  db.drivers.push(...drivers);

  db.review = db.review.filter(
    r => !(r.campaignId === campaign.id && r.type === 'STATUS_INVALIDO'),
  );
  for (const entry of reviewEntries) {
    db.review.push(entry);
  }

  campaign.sheetId = sheetId;
  campaign.sheetName = resolvedSheetName;
  campaign.sheetHeader = header;
  campaign.sheetGid = sheetGid;
  if (typeof name === 'string' && name.trim()) campaign.name = name.trim();
  if (typeof client === 'string') campaign.client = client;
  if (typeof period === 'string') campaign.period = period;
  campaign.updatedAt = now;

  saveDB(db);

  res.json({
    campaign: summarizeCampaign(db, campaign),
    imported,
    review: reviewEntries.length,
    counts,
  });
});

router.delete('/:id', (req, res) => {
  const db = loadDB();
  const index = db.campaigns.findIndex(c => c.id === req.params.id);
  if (index === -1) return res.status(404).json({ error: 'Campanha nao encontrada' });
  const [campaign] = db.campaigns.splice(index, 1);
  db.drivers = db.drivers.filter(d => d.campaignId !== campaign.id);
  db.review = db.review.filter(r => r.campaignId !== campaign.id);
  saveDB(db);
  res.status(204).end();
});

router.post('/:id/drivers', async (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  try {
    const { sheetId, sheetName } = ensureSheetConfig(campaign);
    const fieldsInput = req.body?.fields && typeof req.body.fields === 'object'
      ? req.body.fields
      : req.body;
    if (!fieldsInput || typeof fieldsInput !== 'object') {
      return res.status(400).json({ error: 'Payload invalido' });
    }

    const header =
      Array.isArray(campaign.sheetHeader) && campaign.sheetHeader.length
        ? campaign.sheetHeader
        : await readSheetHeader(sheetId, sheetName);
    campaign.sheetHeader = header;
    campaign.sheetGid = campaign.sheetGid ?? (await getSheetId(sheetId, sheetName));

    const mapKey = key => fieldsInput[key] ?? fieldsInput[key.toLowerCase()] ?? '';
    const name = (fieldsInput.Nome ?? fieldsInput.nome ?? fieldsInput.name ?? '').trim();
    if (!name) return res.status(400).json({ error: 'Campo Nome obrigatorio' });

    const city =
      fieldsInput.Cidade ??
      fieldsInput.cidade ??
      fieldsInput.City ??
      fieldsInput.city ??
      '';
    const statusValue =
      fieldsInput.Status ??
      fieldsInput.status ??
      fieldsInput.STATUS ??
      '';
    const pix =
      fieldsInput.PIX ??
      fieldsInput.Pix ??
      fieldsInput.pix ??
      '';

    const values = header.map(col => mapKey(col));
    const updates = await appendSheetRow(sheetId, sheetName, values);
    const rowNumber = extractRowNumber(updates?.updatedRange);

    const now = Date.now();
    const raw = Object.fromEntries(header.map((col, idx) => [col, values[idx] ?? '']));

    const driver = {
      id: nanoid(),
      campaignId: campaign.id,
      name,
      nameKey: normalizeName(name),
      city,
      pix,
      status: normalizeStatus(statusValue),
      statusRaw: statusValue,
      rowNumber: rowNumber || undefined,
      raw,
      createdAt: now,
      updatedAt: now,
    };

    db.drivers.push(driver);
    campaign.updatedAt = now;
    saveDB(db);

    res.status(201).json({
      driver,
      campaign: summarizeCampaign(db, campaign),
    });
  } catch (err) {
    const status = err.status || 500;
    res.status(status).json({ error: err.message || 'Falha ao adicionar motorista' });
  }
});

router.delete('/:id/drivers/:driverId', async (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const index = db.drivers.findIndex(
    d => d.id === req.params.driverId && d.campaignId === campaign.id,
  );
  if (index === -1) return res.status(404).json({ error: 'Motorista nao encontrado' });

  const driver = db.drivers[index];
  if (!driver.rowNumber) {
    return res.status(400).json({ error: 'Motorista sem referencia de linha para exclusao' });
  }

  try {
    const { sheetId, sheetName } = ensureSheetConfig(campaign);
    const info = await deleteSheetRow(sheetId, sheetName, driver.rowNumber);
    campaign.sheetGid = info.sheetId;
  } catch (err) {
    const status = err.status || 500;
    return res.status(status).json({ error: err.message || 'Falha ao remover na planilha' });
  }
  db.drivers.splice(index, 1);
  db.review = db.review.filter(r => r.driverId !== driver.id);
  for (const other of db.drivers) {
    if (other.campaignId === campaign.id && other.rowNumber && other.rowNumber > driver.rowNumber) {
      other.rowNumber -= 1;
    }
  }

  campaign.updatedAt = Date.now();
  saveDB(db);
  res.json({ campaign: summarizeCampaign(db, campaign) });
});

router.patch('/:id', (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const payload = req.body || {};
  let touched = false;

  if (payload.name && typeof payload.name === 'string') {
    campaign.name = payload.name.trim();
    touched = true;
  }
  if (typeof payload.client === 'string') {
    campaign.client = payload.client;
    touched = true;
  }
  if (typeof payload.period === 'string') {
    campaign.period = payload.period;
    touched = true;
  }
  if (payload.status) {
    const normalized = payload.status.toLowerCase();
    if (!CAMPAIGN_STATUS.includes(normalized)) {
      return res.status(400).json({ error: 'Status invalido' });
    }
    campaign.status = normalized;
    touched = true;
  }

  if (!touched) return res.status(400).json({ error: 'Nenhum campo para atualizar' });

  campaign.updatedAt = Date.now();
  saveDB(db);
  res.json({ campaign: summarizeCampaign(db, campaign) });
});

router.patch('/:id/review/:reviewId', async (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const reviewItem = db.review.find(
    r => r.id === req.params.reviewId && r.campaignId === campaign.id,
  );
  if (!reviewItem) {
    return res.status(404).json({ error: 'Item de revisao nao encontrado' });
  }

  if (reviewItem.type !== 'STATUS_INVALIDO') {
    return res.status(400).json({ error: 'Tipo de revisao nao suportado' });
  }

  const requestedStatus = String(req.body?.status || '').trim();
  if (!requestedStatus) {
    return res.status(400).json({ error: 'Status obrigatorio' });
  }
  const normalizedStatus = normalizeStatus(requestedStatus);
  if (!STATUS.includes(normalizedStatus)) {
    return res.status(400).json({ error: 'Status invalido' });
  }

  const driver = db.drivers.find(
    d => d.id === reviewItem.driverId && d.campaignId === campaign.id,
  );
  if (!driver) return res.status(404).json({ error: 'Motorista nao encontrado' });
  if (!driver.rowNumber) {
    return res.status(400).json({ error: 'Motorista sem referencia de linha para atualizacao' });
  }

  try {
    const { sheetId, sheetName } = ensureSheetConfig(campaign);

    let header =
      Array.isArray(campaign.sheetHeader) && campaign.sheetHeader.length
        ? campaign.sheetHeader
        : null;
    if (!header) {
      header = await readSheetHeader(sheetId, sheetName);
      campaign.sheetHeader = header;
      campaign.sheetGid = campaign.sheetGid ?? (await getSheetId(sheetId, sheetName));
    }

    const columnKey = reviewItem.column || 'Status';
    if (!header.includes(columnKey)) {
      return res.status(400).json({ error: `Coluna ${columnKey} nao encontrada na planilha` });
    }

    const raw = { ...(driver.raw || {}) };
    raw[columnKey] = normalizedStatus;
    driver.raw = raw;
    driver.status = normalizedStatus;
    driver.statusRaw = normalizedStatus;
    driver.updatedAt = Date.now();

    const values = header.map(col => raw[col] ?? '');
    await updateSheetRow(sheetId, sheetName, driver.rowNumber, values);

    db.review = db.review.filter(r => r.id !== reviewItem.id);
    campaign.updatedAt = Date.now();
    saveDB(db);

    res.json({
      driver,
      campaign: summarizeCampaign(db, campaign),
    });
  } catch (err) {
    const status = err.status || 500;
    res.status(status).json({ error: err.message || 'Falha ao aplicar revisao' });
  }
});

router.delete('/:id/review/:reviewId', (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const exists = db.review.some(
    r => r.id === req.params.reviewId && r.campaignId === campaign.id,
  );
  if (!exists) return res.status(404).json({ error: 'Item de revisao nao encontrado' });

  db.review = db.review.filter(r => r.id !== req.params.reviewId);
  saveDB(db);
  res.status(204).end();
});

router.patch('/:id/drivers/:driverId', async (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const driver = db.drivers.find(
    d => d.id === req.params.driverId && d.campaignId === campaign.id,
  );
  if (!driver) return res.status(404).json({ error: 'Motorista nao encontrado' });
  if (!driver.rowNumber) {
    return res.status(400).json({ error: 'Motorista sem referencia de linha para atualizacao' });
  }

  const fieldsInput = req.body?.fields && typeof req.body.fields === 'object'
    ? req.body.fields
    : req.body;

  if (!fieldsInput || typeof fieldsInput !== 'object') {
    return res.status(400).json({ error: 'Payload invalido' });
  }

  try {
    const { sheetId, sheetName } = ensureSheetConfig(campaign);

    let header =
      Array.isArray(campaign.sheetHeader) && campaign.sheetHeader.length
        ? campaign.sheetHeader
        : null;
    if (!header) {
      header = await readSheetHeader(sheetId, sheetName);
      campaign.sheetHeader = header;
      campaign.sheetGid = campaign.sheetGid ?? (await getSheetId(sheetId, sheetName));
    }

    const raw = { ...(driver.raw || {}) };
    Object.entries(fieldsInput).forEach(([key, value]) => {
      raw[key] = value;
    });

    const values = header.map(col => raw[col] ?? '');
    await updateSheetRow(sheetId, sheetName, driver.rowNumber, values);

    if ('Nome' in fieldsInput || 'nome' in fieldsInput || 'name' in fieldsInput) {
      const name =
        fieldsInput.Nome ??
        fieldsInput.nome ??
        fieldsInput.name ??
        driver.name;
      driver.name = name;
      driver.nameKey = normalizeName(name);
    }
    if ('Cidade' in fieldsInput || 'cidade' in fieldsInput) {
      driver.city = fieldsInput.Cidade ?? fieldsInput.cidade;
    }
    if ('PIX' in fieldsInput || 'Pix' in fieldsInput || 'pix' in fieldsInput) {
      driver.pix = fieldsInput.PIX ?? fieldsInput.Pix ?? fieldsInput.pix;
    }
    if ('Status' in fieldsInput || 'status' in fieldsInput || 'STATUS' in fieldsInput) {
      const rawStatus =
        fieldsInput.Status ??
        fieldsInput.status ??
        fieldsInput.STATUS ??
        driver.status;
      driver.statusRaw = rawStatus;
      driver.status = normalizeStatus(rawStatus);
    }

    driver.raw = raw;
    driver.updatedAt = Date.now();
    campaign.updatedAt = Date.now();
    saveDB(db);

    res.json({ driver });
  } catch (err) {
    const status = err.status || 500;
    res.status(status).json({ error: err.message || 'Falha ao atualizar motorista' });
  }
});

// Update KM row for a driver (editable KM sheet fields)
router.patch('/:id/km/:driverId', async (req, res) => {
  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === req.params.id);
  if (!campaign) return res.status(404).json({ error: 'Campanha nao encontrada' });

  const driver = db.drivers.find(
    d => d.id === req.params.driverId && d.campaignId === campaign.id,
  );
  if (!driver) return res.status(404).json({ error: 'Motorista nao encontrado' });

  // KM sheet mapping (may be absent) - if present we update the remote sheet, otherwise we store locally
  const sheetId = campaign.kmSheetId || campaign.sheetId || '';
  const sheetName = campaign.kmSheetName || campaign.sheetName || '';
  const header = Array.isArray(campaign.kmSheetHeader) && campaign.kmSheetHeader.length
    ? campaign.kmSheetHeader
    : null;

  const fieldsInput = req.body?.fields && typeof req.body.fields === 'object'
    ? req.body.fields
    : req.body;
  if (!fieldsInput || typeof fieldsInput !== 'object') {
    return res.status(400).json({ error: 'Payload invalido' });
  }

  // rowNumber required only when we intend to update the remote sheet
  if ((sheetId && sheetName && header) && !driver.rowNumber) {
    return res.status(400).json({ error: 'Motorista sem referencia de linha para atualizacao de KM' });
  }

  try {
    // Merge into existing km.raw (or build new)
    const raw = { ...(driver.km?.raw || {}) };
    Object.entries(fieldsInput).forEach(([key, value]) => {
      raw[key] = value;
    });

    // If we have a sheet mapping, update the remote sheet; otherwise just store locally
    if (sheetId && sheetName && header) {
      // Build values array according to header order
      const values = header.map(col => raw[col] ?? '');
      // Update sheet row (rowNumber refers to KM sheet row)
      await updateSheetRow(sheetId, sheetName, driver.rowNumber, values);
    }

    // Rebuild km data snapshot minimally (store raw regardless)
    driver.km = driver.km || {};
    driver.km.raw = raw;
    driver.km.importedAt = Date.now();
    driver.updatedAt = Date.now();

    campaign.updatedAt = Date.now();
    saveDB(db);

    res.json({ driver });
  } catch (err) {
    const status = err.status || 500;
    res.status(status).json({ error: err.message || 'Falha ao atualizar KM' });
  }
});

export default router;


=== FILE: backend\routes\imports.js ===

import { Router } from 'express';
import fs from 'fs';
import { nanoid } from 'nanoid';
import { readSheetByRange, readSheetHeader, getSheetId } from '../services/sheets.js';
import { normalizeName } from '../lib/normalize.js';
import { buildDriversFromRows, resolveSheetName } from '../lib/campaignImport.js';

const DB_PATH = new URL('../data/db.json', import.meta.url);

function loadDB() {
  try {
    return JSON.parse(fs.readFileSync(DB_PATH));
  } catch {
    return { campaigns: [], drivers: [], review: [] };
  }
}

function saveDB(db) {
  fs.writeFileSync(DB_PATH, JSON.stringify(db, null, 2));
}

const router = Router();

// Importa a planilha principal da campanha (aba Pagina1 por padrao)
router.post('/campaign', async (req, res) => {
  const {
    spreadsheetId,
    sheetName = 'Pagina1',
    campaignName,
    client = '',
    period = '',
  } = req.body;

  if (!spreadsheetId) {
    return res.status(400).json({ error: 'spreadsheetId obrigatorio' });
  }

  const resolvedSheetName = resolveSheetName(sheetName, 'Pagina1');
  const rows = await readSheetByRange(
    spreadsheetId,
    `${resolvedSheetName}!A:Z`,
  );
  const header = await readSheetHeader(spreadsheetId, resolvedSheetName);
  const sheetGid = await getSheetId(spreadsheetId, resolvedSheetName);
  const db = loadDB();

  const campaignId = nanoid();
  const now = Date.now();

  db.campaigns.push({
    id: campaignId,
    name: campaignName || `Campanha ${campaignId.slice(0, 5)}`,
    client,
    period,
    status: 'ativa',
    sheetId: spreadsheetId,
    sheetName: resolvedSheetName,
    sheetHeader: header,
    sheetGid,
    createdAt: now,
    updatedAt: now,
  });

  const { drivers, counts, imported, reviewEntries } = buildDriversFromRows(rows, {
    campaignId,
    now,
  });

  db.drivers.push(...drivers);

  for (const entry of reviewEntries) {
    db.review.push(entry);
  }

  saveDB(db);
  res.json({
    campaignId,
    imported,
    review: reviewEntries.length,
    counts,
  });
});

// Importa planilha de KM (Planilha1) e tenta vincular por nome normalizado
router.post('/km', async (req, res) => {
  const { spreadsheetId, sheetName = 'Planilha1', campaignId } = req.body;

  if (!spreadsheetId || !campaignId) {
    return res
      .status(400)
      .json({ error: 'spreadsheetId e campaignId sao obrigatorios' });
  }

  const resolvedSheetName = resolveSheetName(sheetName, 'Planilha1');
  let rows;
  try {
    rows = await readSheetByRange(
      spreadsheetId,
      `${resolvedSheetName}!A:Z`,
    );
  } catch (err) {
    const remoteMessage = err?.response?.data?.error?.message || err?.message || String(err);
    console.error('Error reading KM sheet', remoteMessage, err);
    const reason = err?.response?.data?.error?.errors?.[0]?.reason;
    const hint = reason === 'failedPrecondition'
      ? 'Possivel causa: o arquivo informado nao Ã© uma planilha Google (Sheets) ou a operacao nao Ã© suportada para este documento.'
      : 'Verifique se o ID estÃ¡ correto e se a conta de servico (GOOGLE_CLIENT_EMAIL) tem acesso a planilha.';
    return res.status(400).json({
      error: 'Nao foi possivel importar a planilha de KM.',
      detail: remoteMessage,
      hint,
    });
  }

  const db = loadDB();
  const campaign = db.campaigns.find(c => c.id === campaignId);
  if (!campaign) {
    return res.status(404).json({ error: 'Campanha nao encontrada' });
  }

  const drivers = db.drivers.filter(d => d.campaignId === campaignId);
  const driversById = new Map(drivers.map(d => [d.id, d]));
  const driversByName = new Map(drivers.map(d => [d.nameKey, d]));

  // remove entradas anteriores de KM_MATCH para esta campanha
  db.review = db.review.filter(r => !(r.campaignId === campaignId && r.type === 'KM_MATCH'));

  let linked = 0;
  const reviewEntries = [];
  const now = Date.now();

  // Save reference to the KM sheet used for this import so we can
  // update KM rows later (sheetId, sheetName and header)
  try {
    campaign.kmSheetId = spreadsheetId;
    campaign.kmSheetName = resolvedSheetName;
    campaign.kmSheetHeader = await readSheetHeader(spreadsheetId, resolvedSheetName);
  } catch (err) {
    // ignore header read failure; not critical for import to succeed
    console.warn('Failed to read KM sheet header for campaign', campaignId, err?.message || err);
  }

  campaign.updatedAt = now;

  for (const row of rows) {
    const rowNumber = row.__rowNumber || null;
    const normalizedRow = normalizeRowKeys(row);
    const raw = buildRawSnapshot(row);

    const nameValue = pick(normalizedRow, ['NOME', 'NAME']);
    const nome = String(nameValue || '').trim();
    if (!nome) continue;
    const nameKey = normalizeName(nome);

    const driverIdValue = pick(normalizedRow, ['_DRIVERID', '_DRIVER ID', 'DRIVERID', 'DRIVER ID']);
    const driverIdTrimmed = driverIdValue ? String(driverIdValue).trim() : '';
    let driver = null;
    if (driverIdTrimmed && driversById.has(driverIdTrimmed)) {
      driver = driversById.get(driverIdTrimmed);
    } else if (driversByName.has(nameKey)) {
      driver = driversByName.get(nameKey);
    }

    const kmData = buildKmData(normalizedRow, raw, rowNumber, nome, now);

    if (!driver) {
      reviewEntries.push({
        id: nanoid(),
        type: 'KM_MATCH',
        campaignId,
        driverId: null,
        driverName: nome,
        rowNumber,
        payload: kmData.raw,
        note: 'Motorista nao encontrado para a linha de KM',
        createdAt: now,
      });
      continue;
    }

    driver.km = kmData;
    driver.updatedAt = now;
    linked += 1;
  }

  for (const entry of reviewEntries) {
    db.review.push(entry);
  }

  campaign.updatedAt = now;
  saveDB(db);

  res.json({ linked, review: reviewEntries.length });
});

export default router;

function normalizeRowKeys(row) {
  const normalized = {};
  for (const [key, value] of Object.entries(row)) {
    if (key === '__rowNumber') continue;
    const normKey = normalizeHeaderKey(key);
    normalized[normKey] = value ?? '';
  }
  return normalized;
}

function buildRawSnapshot(row) {
  const snapshot = {};
  for (const [key, value] of Object.entries(row)) {
    if (key === '__rowNumber') continue;
    snapshot[key] = value ?? '';
  }
  return snapshot;
}

function normalizeHeaderKey(key) {
  return String(key || '')
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .replace(/\s+/g, ' ')
    .trim()
    .toUpperCase();
}

function pick(row, keys) {
  for (const key of keys) {
    const normalized = normalizeHeaderKey(key);
    if (row[normalized] !== undefined && String(row[normalized]).trim() !== '') {
      return row[normalized];
    }
  }
  const first = normalizeHeaderKey(keys[0]);
  return row[first];
}

function normalizeNumber(val) {
  if (val === undefined || val === null) return null;
  const str = String(val).trim();
  if (!str) return null;
  const sanitized = str.replace(/\./g, '').replace(/,/g, '.').replace('%', '');
  const num = Number(sanitized);
  return Number.isFinite(num) ? num : null;
}

function normalizeDate(val) {
  if (!val) return '';
  const str = String(val).trim();
  if (!str) return '';

  if (/^\d{4}-\d{2}-\d{2}$/.test(str)) return str;

  const matchDMY = str.match(/^(\d{2})\/(\d{2})\/(\d{2}|\d{4})$/);
  if (matchDMY) {
    const day = matchDMY[1];
    const month = matchDMY[2];
    let year = matchDMY[3];
    if (year.length === 2) {
      year = Number(year) + 2000;
    }
    return `${year}-${month}-${day}`;
  }

  const matchYMD = str.match(/^(\d{4})\/(\d{2})\/(\d{2})$/);
  if (matchYMD) {
    return `${matchYMD[1]}-${matchYMD[2]}-${matchYMD[3]}`;
  }

  return '';
}

function normalizeInt(val) {
  const num = normalizeNumber(val);
  return Number.isFinite(num) ? Math.round(num) : null;
}

function derivePercent(rawStatus, km, meta) {
  const value = normalizeNumber(rawStatus);
  if (value !== null) return value;
  if (km !== null && meta !== null && meta !== 0) {
    return (km / meta) * 100;
  }
  return null;
}

function deriveStatus(rawStatus, percent) {
  const normalized = normalizeHeaderKey(rawStatus || '');
  if (normalized === 'OK') return 'OK';
  if (normalized === 'ATENCAO' || normalized === 'ATENÃ‡ÃƒO') return 'AtenÃ§Ã£o';
  if (normalized === 'CRITICO' || normalized === 'CRÃTICO') return 'CrÃ­tico';

  if (percent === null || !Number.isFinite(percent)) return '';
  if (percent >= 100) return 'OK';
  if (percent >= 80) return 'AtenÃ§Ã£o';
  return 'CrÃ­tico';
}

function buildKmData(row, raw, rowNumber, nome, timestamp) {
  const periods = [];
  for (let i = 1; i <= 3; i += 1) {
    const dataInicio = normalizeDate(pick(row, [`DATA INICIO ${i}`, `DATA INICIO${i}`]));
    const dataAtual = normalizeDate(pick(row, [`DATA ATUAL ${i}`, `DATA ATUAL${i}`]));
    const qtdeDias = normalizeInt(pick(row, [`QTDE DIAS ${i}`, `QTDE DIAS${i}`]));
    const kmRodado = normalizeNumber(pick(row, [`KM RODADO ${i}`, `KM RODADO${i}`, `KM ${i}`]));
    const metaKm = normalizeNumber(pick(row, [`META KM ${i}`, `META KM${i}`]));
    const statusRaw = pick(row, [`STATUS ${i}`]);
    const percent = derivePercent(statusRaw, kmRodado, metaKm);
    const status = deriveStatus(statusRaw, percent);

    const hasData = [dataInicio, dataAtual, qtdeDias, kmRodado, metaKm, statusRaw]
      .some(value => value !== null && value !== '' && value !== undefined);

    if (!hasData) continue;

    periods.push({
      index: i,
      dataInicio,
      dataAtual,
      qtdeDias,
      kmRodado,
      metaKm,
      status,
      statusRaw: statusRaw ?? '',
      percent,
    });
  }

  const km1 = normalizeNumber(pick(row, ['KM RODADO 1', 'KM RODADO1', 'KM 1']));
  const km2 = normalizeNumber(pick(row, ['KM RODADO 2', 'KM RODADO2', 'KM 2']));
  const km3 = normalizeNumber(pick(row, ['KM RODADO 3', 'KM RODADO3', 'KM 3']));
  const meta1 = normalizeNumber(pick(row, ['META KM 1', 'META KM1']));
  const meta2 = normalizeNumber(pick(row, ['META KM 2', 'META KM2']));
  const meta3 = normalizeNumber(pick(row, ['META KM 3', 'META KM3']));

  let kmTotal = normalizeNumber(pick(row, ['KM RODADO TOTAL', 'KM TOTAL']));
  if (kmTotal === null) {
    const parts = [km1, km2, km3].filter(n => Number.isFinite(n));
    if (parts.length) kmTotal = parts.reduce((acc, cur) => acc + cur, 0);
  }

  let metaTotal = normalizeNumber(pick(row, ['META KM TOTAL', 'META TOTAL']));
  if (metaTotal === null) {
    const parts = [meta1, meta2, meta3].filter(n => Number.isFinite(n));
    if (parts.length) metaTotal = parts.reduce((acc, cur) => acc + cur, 0);
  }

  const statusTotalRaw = pick(row, ['STATUS TOTAL']);
  const percentTotal = derivePercent(statusTotalRaw, kmTotal, metaTotal);
  const statusTotal = deriveStatus(statusTotalRaw, percentTotal);

  const checkIn = pick(row, ['CHECK IN', 'CHECK-IN', 'CHECKIN']) ?? '';
  const comentarios = pick(row, ['COMENTARIOS', 'COMENTÃRIOS', 'COMENTARIO']) ?? '';
  const observacoes = pick(row, ['OBSERVACOES', 'OBSERVAÃ‡Ã•ES']) ?? '';
  const extra = {
    adri: pick(row, ['ADRI']),
  };

  return {
    rowNumber,
    importedAt: timestamp,
    name: nome,
    periods,
    total: {
      kmRodado: kmTotal,
      metaKm: metaTotal,
      status: statusTotal,
      statusRaw: statusTotalRaw ?? '',
      percent: percentTotal,
    },
    summary: {
      km1,
      km2,
      km3,
      meta1,
      meta2,
      meta3,
    },
    checkIn,
    comentarios,
    observacoes,
    raw,
    extra,
  };
}


=== FILE: backend\server.js ===

import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import campaignsRouter from './routes/campaigns.js';
import importsRouter from './routes/imports.js';

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// API
app.use('/api/campaigns', campaignsRouter);
app.use('/api/imports', importsRouter);

// servir o frontend estatico (desktop-first)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
app.use('/', express.static(path.join(__dirname, '..', 'frontend')));

const PORT = process.env.PORT || 5173;
app.listen(PORT, () => console.log(`Admin rodando em http://localhost:${PORT}`));


=== FILE: backend\services\drive.js ===


=== FILE: backend\services\sheets.js ===

import { google } from 'googleapis';

const auth = new google.auth.GoogleAuth({
  credentials: {
    client_email: process.env.GOOGLE_CLIENT_EMAIL,
    private_key: (process.env.GOOGLE_PRIVATE_KEY || '').replace(/\\n/g, '\n'),
  },
  scopes: [
    'https://www.googleapis.com/auth/spreadsheets',
    'https://www.googleapis.com/auth/drive',
  ],
});

async function getSheetsClient() {
  return google.sheets({ version: 'v4', auth: await auth.getClient() });
}

function formatSheetRange(sheetName, range) {
  const safeName = sheetName.includes("'")
    ? `'${sheetName.replace(/'/g, "''")}'`
    : sheetName.includes(' ')
    ? `'${sheetName}'`
    : sheetName;
  return `${safeName}!${range}`;
}

export async function readSheetByRange(spreadsheetId, rangeA1) {
  const sheets = await getSheetsClient();
  const { data } = await sheets.spreadsheets.values.get({
    spreadsheetId,
    range: rangeA1,
  });
  const [header = [], ...rows] = data.values || [];
  return rows.map((row, index) => {
    const entry = Object.fromEntries(
      header.map((col, i) => [String(col || '').trim(), row[i] ?? '']),
    );
    entry.__rowNumber = index + 2; // inclui cabecalho
    return entry;
  });
}

export async function readSheetHeader(spreadsheetId, sheetName) {
  const sheets = await getSheetsClient();
  const range = formatSheetRange(sheetName, '1:1');
  const { data } = await sheets.spreadsheets.values.get({
    spreadsheetId,
    range,
  });
  const headerRow = (data.values && data.values[0]) || [];
  return headerRow.map(col => String(col || '').trim());
}

export async function appendSheetRow(spreadsheetId, sheetName, values) {
  const sheets = await getSheetsClient();
  const range = formatSheetRange(sheetName, 'A1');
  const response = await sheets.spreadsheets.values.append({
    spreadsheetId,
    range,
    valueInputOption: 'USER_ENTERED',
    insertDataOption: 'INSERT_ROWS',
    requestBody: { values: [values] },
  });
  return response.data.updates;
}

async function getSheetMeta(spreadsheetId, sheetName) {
  const sheets = await getSheetsClient();
  const { data } = await sheets.spreadsheets.get({ spreadsheetId });
  const sheet = (data.sheets || []).find(
    s => s.properties && s.properties.title === sheetName,
  );
  if (!sheet) throw new Error(`Sheet ${sheetName} nao encontrada`);
  return sheet.properties;
}

export async function deleteSheetRow(spreadsheetId, sheetName, rowNumberOneBased) {
  const sheetProps = await getSheetMeta(spreadsheetId, sheetName);
  const sheets = await getSheetsClient();
  const startIndex = Math.max(0, rowNumberOneBased - 1);
  await sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    requestBody: {
      requests: [
        {
          deleteDimension: {
            range: {
              sheetId: sheetProps.sheetId,
              dimension: 'ROWS',
              startIndex,
              endIndex: startIndex + 1,
            },
          },
        },
      ],
    },
  });
  return { sheetId: sheetProps.sheetId };
}

export async function getSheetId(spreadsheetId, sheetName) {
  const props = await getSheetMeta(spreadsheetId, sheetName);
  return props.sheetId;
}

function columnIndexToLetter(index) {
  let result = '';
  let current = index + 1;
  while (current > 0) {
    const modulo = (current - 1) % 26;
    result = String.fromCharCode(65 + modulo) + result;
    current = Math.floor((current - modulo) / 26);
  }
  return result;
}

export async function updateSheetRow(spreadsheetId, sheetName, rowNumberOneBased, values) {
  if (rowNumberOneBased < 1) throw new Error('Indice de linha invalido');
  const sheets = await getSheetsClient();

  const lastColumnLetter = columnIndexToLetter(Math.max(values.length - 1, 0));
  const range = formatSheetRange(
    sheetName,
    values.length ? `A${rowNumberOneBased}:${lastColumnLetter}${rowNumberOneBased}` : `A${rowNumberOneBased}`,
  );

  await sheets.spreadsheets.values.update({
    spreadsheetId,
    range,
    valueInputOption: 'USER_ENTERED',
    requestBody: {
      values: [values],
    },
  });

  return { range };
}


=== FILE: frontend\assets\styles.css ===

/* ===========================
   OD DRIVE - ADMIN UI (Desktop-first, responsivo)
   Tipografia e tokens visuais baseados nos mocks enviados
   =========================== */
@import url('https://fonts.googleapis.com/css2?family=Work+Sans:wght@400;500;600;700&display=swap');

:root{
  --bg: #f6f7f8;
  --bg-weak: #eef1f4;
  --card: #ffffff;
  --text: #101922;
  --muted: #6b7785;
  --line: #e6e9ed;
  --primary: #1173d4;
  --primary-weak: #e5f0fb;
  --success: #17b26a;
  --warning: #f5a524;
  --danger: #e53935;
  --shadow: 0 6px 24px rgba(16,25,34,0.06), 0 2px 8px rgba(16,25,34,0.04);
  --radius: 16px;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font: 14px/1.5 "Work Sans", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

/* Container responsivo */
.container{
  width:min(1200px, 92vw);
  margin: 0 auto;
  padding: 24px 0 48px;
}

/* Topbar */
.topbar{
  position: sticky; top:0; z-index: 10;
  background: var(--card);
  border-bottom:1px solid var(--line);
  box-shadow: 0 2px 8px rgba(16,25,34,0.02);
}
.topbar .wrap{
  width:min(1200px, 92vw);
  margin:auto; padding: 14px 0;
  display:flex; align-items:center; gap:16px; justify-content:space-between;
}
.brand{
  display:flex; align-items:center; gap:12px;
}
.brand h1{
  font-size: 20px; margin:0; letter-spacing:.2px;
}
.actions{ display:flex; gap:10px; }

/* Botoes */
.btn{
  appearance:none; border:1px solid transparent; cursor:pointer;
  background:var(--card); color:var(--text);
  padding:10px 14px; border-radius:12px; font-weight:600;
  transition:.15s ease;
}
.btn--primary{ background:var(--primary); color:#fff; }
.btn--ghost{ border-color: var(--line); }
.btn--danger{ background:var(--danger); color:#fff; }
.btn:disabled{ opacity:.6; cursor:not-allowed; }
.btn:hover{ transform: translateY(-1px); box-shadow: var(--shadow); }

.link-button{
  appearance:none; border:none; background:none;
  padding:0; font:inherit;
  color:var(--primary); cursor:pointer;
  text-decoration:underline;
}
.link-button:hover{ color:#0e5fb0; }

/* Chips (filtros) */
.chips{ display:flex; gap:8px; flex-wrap:wrap; margin: 20px 0 12px; }
.chip{
  background: var(--bg-weak); color: var(--text); border:1px solid var(--line);
  padding:8px 12px; border-radius:999px; font-weight:600; cursor:pointer;
}
.chip.active{ background: var(--primary); color:#fff; border-color:transparent; }

/* Grid de cards */
.grid-cards{
  display:grid; gap:16px;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}
.card{
  background:var(--card); border:1px solid var(--line);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding:16px; display:flex; flex-direction:column; gap:10px;
}
.card-head{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
.card h3{ margin:0; font-size:18px; }
.pill{
  padding:6px 10px; border-radius:999px; font-size:12px; font-weight:700;
  background: var(--primary-weak); color: var(--primary);
  border:1px solid #cfe3fb;
}
.pill.success{ background:#eaf8f1; color:var(--success); border-color:#cceede; }
.pill.warn{ background:#fff4e0; color:var(--warning); border-color:#ffe1aa; }
.pill.danger{ background:#ffe9e7; color:var(--danger); border-color:#ffc8c2; }

.card-meta{ display:flex; gap:8px; flex-wrap:wrap; color:var(--muted); font-size:12px; }
.counts{ display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
.count{ background:var(--bg-weak); border:1px solid var(--line); border-radius:10px; padding:6px 8px; font-weight:600; font-size:12px; }
.card-actions{ display:flex; gap:8px; margin-top:6px; flex-wrap:wrap; }

/* Tabs (campaign.html) */
.tabs{
  display:flex; gap:8px; flex-wrap:wrap; border-bottom:1px solid var(--line); margin-bottom:16px;
}
.tab{
  padding:10px 12px; border-radius:12px 12px 0 0; font-weight:600; cursor:pointer;
  border:1px solid transparent; border-bottom:none; color:var(--muted);
}
.tab.active{ color:var(--text); background:var(--card); border-color:var(--line); }
.tab-panels{ background:var(--card); border:1px solid var(--line); border-radius:0 12px 12px 12px; box-shadow:var(--shadow); padding:16px; }
.tab-panel{ display:none; }
.tab-panel.active{ display:block; }

.tab-toolbar{
  display:flex;
  justify-content:flex-end;
  margin-bottom:12px;
}
.toolbar-actions{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}
.toolbar-actions{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}

/* KPIs */
.kpis{ display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(180px,1fr)); }
.kpi{ background:var(--bg-weak); border:1px solid var(--line); border-radius:14px; padding:14px; }
.kpi .label{ color:var(--muted); font-size:12px; }
.kpi .value{ font-weight:800; font-size:22px; }

/* Tabelas */
.table{ width:100%; border-collapse: collapse; }
.table th, .table td{ padding:10px 12px; border-bottom:1px solid var(--line); text-align:left; }
.table th{ font-size:12px; letter-spacing:.2px; color:var(--muted); text-transform:uppercase; }
.period-cell{ white-space: nowrap; }
.table .status{
  display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-weight:700; font-size:12px;
  background: var(--bg-weak); border:1px solid var(--line);
}
.table tr.pending-row{
  background:#fff4d6;
}
.review-actions{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}
.review-actions .review-status-select{
  min-width:140px;
}
.driver-input{
  width:100%;
  border:1px solid var(--line);
  border-radius:10px;
  padding:6px 8px;
  font:inherit;
  background:#fff;
}
.table .empty-row{
  text-align:center;
  padding:18px 0;
  color:var(--muted);
  font-style:italic;
}
.status.agendado{ background:#eef6ff; color:#0b6bd6; border-color:#cfe3fb; }
.status.confirmado{ background:#eaf8f1; color:#17b26a; border-color:#cceede; }
.status.instalado{ background:#edf7ff; color:#1479ff; border-color:#cfe3fb; }
.status.aguardando{ background:#fffbea; color:#b08900; border-color:#ffe1aa; }
.status.cadastrando{ background:#f3f4f6; color:#5d6672; border-color:#e4e7eb; }
.status.problema{ background:#ffe9e7; color:#e53935; border-color:#ffc8c2; }
.status.revisar{ background:#f0ecff; color:#5b3fd1; border-color:#d8cffc; }

.status.ok{ background:#eaf8f1; color:#17b26a; border-color:#cceede; }
.status.atencao{ background:#fff4e0; color:#f5a524; border-color:#ffd79a; }
.status.critico{ background:#ffe9e7; color:#e53935; border-color:#ffc8c2; }
.pill-select{
  appearance:none;
  padding:6px 12px;
  border-radius:999px;
  border:1px solid #cfe3fb;
  background:var(--primary-weak);
  color:var(--primary);
  font-weight:700;
}

/* Modal */
.modal{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:20;
}
.modal.hidden{ display:none; }
.modal-backdrop{
  position:absolute;
  inset:0;
  background:rgba(16,25,34,0.45);
}
.modal-card{
  position:relative;
  background:var(--card);
  border-radius:20px;
  padding:24px;
  width:min(640px, 92vw);
  max-height:86vh;
  overflow:auto;
  box-shadow:var(--shadow);
}
.modal-title{
  margin:0 0 16px;
  font-size:20px;
}
.modal-body{ font-size:14px; }
.modal-close{
  position:absolute;
  top:16px;
  right:16px;
  width:32px;
  height:32px;
  border:none;
  border-radius:50%;
  background:var(--bg-weak);
  color:var(--text);
  font-size:18px;
  cursor:pointer;
}
.modal-close:hover{ background:var(--line); }
.modal-actions{
  margin-top:20px;
  display:flex;
  gap:12px;
  justify-content:flex-end;
  flex-wrap:wrap;
}

.details-grid{
  display:grid;
  gap:12px;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
.details-grid dt{
  margin:0;
  font-weight:600;
  color:var(--muted);
  font-size:12px;
  text-transform:uppercase;
}
.details-grid dd{
  margin:2px 0 0;
  font-size:14px;
  word-break:break-word;
}

.form-grid{
  display:grid;
  gap:12px;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
.form-group{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.form-group label{
  font-size:12px;
  font-weight:600;
  color:var(--muted);
}
.form-group input,
.form-group select,
.form-group textarea{
  border:1px solid var(--line);
  border-radius:10px;
  padding:8px 10px;
  font:inherit;
  background:#fff;
}
.form-group textarea{
  min-height:64px;
  resize:vertical;
}

/* KM cards */
/* (KM cards UI removed; kept table-based layout) */

/* Helpers */
.m0{margin:0}
.mt8{margin-top:8px}
.mt12{margin-top:12px}
.mt16{margin-top:16px}
hr{ border:none; border-top:1px solid var(--line); margin:16px 0; }
.small{ font-size:12px; color:var(--muted); }
.muted{ color:var(--muted); }

@media (max-width: 760px){
  .brand h1{ font-size:18px; }
  .modal-card{ padding:20px; }
}


=== FILE: frontend\campaign.html ===

<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OD Drive - Campanha</title>
  <link rel="stylesheet" href="assets/styles.css" />
</head>
<body>
  <div class="topbar">
    <div class="wrap">
      <div class="brand">
        <a href="index.html" class="btn btn--ghost">&larr; Voltar</a>
        <h1 id="campTitle">Nome da Campanha</h1>
      </div>
      <div class="actions">
        <button class="btn" id="btnSync">Sincronizar</button>
        <button class="btn" id="btnReport">Relatorio Parcial</button>
        <button class="btn btn--danger" id="btnDelete">Excluir Campanha</button>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Tabs -->
    <div class="tabs" id="tabs">
      <button class="tab active" data-tab="resumo">Resumo</button>
      <button class="tab" data-tab="motoristas">Motoristas</button>
      <button class="tab" data-tab="grafica">Grafica</button>
      <button class="tab" data-tab="km">KM / Metas</button>
      <button class="tab" data-tab="revisar">Revisar</button>
      <button class="tab" data-tab="config">Configuracoes</button>
    </div>

    <div class="tab-panels">
      <!-- Resumo -->
      <section class="tab-panel active" id="tab-resumo">
        <div class="kpis">
          <div class="kpi">
            <div class="label">Aderencia media</div>
            <div class="value" id="kpiAd">-</div>
          </div>
          <div class="kpi">
            <div class="label">KM total</div>
            <div class="value" id="kpiKm">-</div>
          </div>
          <div class="kpi">
            <div class="label">Instalados</div>
            <div class="value" id="kpiInst">-</div>
          </div>
          <div class="kpi">
            <div class="label">Revisar</div>
            <div class="value" id="kpiRev">-</div>
          </div>
        </div>
        <hr/>
        <div class="grid-cards">
          <article class="card">
            <div class="card-head">
              <h3 class="m0">Status da campanha</h3>
              <select id="campaignStatus" class="pill-select"></select>
            </div>
            <p class="small">Periodo: <span id="campPeriod">-</span> &middot; Cliente: <span id="campClient">-</span></p>
            <div class="counts">
              <div class="count">Agendado: <b id="cAg">0</b></div>
              <div class="count">Confirmado: <b id="cCf">0</b></div>
              <div class="count">Instalado: <b id="cIn">0</b></div>
              <div class="count">Problema: <b id="cPb">0</b></div>
              <div class="count">Revisar: <b id="cRv">0</b></div>
            </div>
          </article>
          <article class="card">
            <div class="card-head">
              <h3 class="m0">Proximas acoes</h3>
              <span class="pill warn">Agenda</span>
            </div>
            <ul class="small m0" id="nextSteps">
              <li>Resolver pendencias da fila Revisar</li>
              <li>Conferir confirmacoes com a equipe de campo</li>
              <li>Sincronizar status da grafica</li>
            </ul>
          </article>
        </div>
      </section>

      <!-- Motoristas -->
      <section class="tab-panel" id="tab-motoristas">
        <div class="tab-toolbar">
          <div class="toolbar-actions">
            <button class="btn" id="btnSaveDrivers" disabled>Salvar alteracoes</button>
            <button class="btn btn--primary" id="btnAddDriver">Adicionar motorista</button>
          </div>
        </div>
        <table class="table" data-empty="Sem motoristas para esta campanha.">
          <thead>
            <tr>
              <th>Nome</th><th>Cidade</th><th>Status</th><th>Aderencia</th><th>KM Total</th><th>Acoes</th>
            </tr>
          </thead>
          <tbody id="tblDrivers">
            <!-- preenchido via JS -->
          </tbody>
        </table>
      </section>

      <!-- Grafica -->
      <section class="tab-panel" id="tab-grafica">
        <div class="grid-cards">
          <article class="card">
            <div class="card-head">
              <h3 class="m0">Pipeline</h3>
              <span class="pill">Em breve</span>
            </div>
            <p class="small m0">Status detalhado da producao grafica ficara disponivel aqui.</p>
          </article>
          <article class="card">
            <div class="card-head">
              <h3 class="m0">Evidencias</h3>
              <span class="pill">Uploads</span>
            </div>
            <p class="small m0">Uploads da grafica e da equipe aparecerao neste bloco.</p>
          </article>
        </div>
      </section>

      <!-- KM / Metas -->
      <section class="tab-panel" id="tab-km">
        <div class="tab-toolbar">
          <div class="toolbar-actions">
              <button class="btn btn--primary" id="btnImportKm">Importar KM</button>
              <button class="btn" id="btnSyncKm">Sincronizar KM</button>
            </div>
        </div>
  <table class="table" data-empty="Sem dados de KM importados.">
          <thead>
            <tr>
              <th>Nome</th><th>Periodo</th><th>KM Rodado</th><th>Meta</th><th>%</th><th>Status</th><th>Check-in</th><th>Observacoes</th>
            </tr>
          </thead>
          <tbody id="tblKm">
            <!-- preenchido via JS -->
          </tbody>
        </table>
      </section>

      <!-- Revisar -->
      <section class="tab-panel" id="tab-revisar">
        <table class="table" data-empty="Nenhum item em Revisar.">
          <thead><tr><th>Tipo</th><th>Descricao</th><th>Acao</th></tr></thead>
          <tbody id="tblReview">
            <!-- preenchido via JS -->
          </tbody>
        </table>
      </section>

      <!-- Configuracoes -->
      <section class="tab-panel" id="tab-config">
        <p class="small" id="configInfo">IDs / links de planilhas, agenda de sincronizacao e permissoes aparecerao aqui.</p>
      </section>
    </div>
  </div>

  <div class="modal hidden" id="driverDetailModal" aria-hidden="true">
    <div class="modal-backdrop" data-modal-dismiss></div>
    <div class="modal-card">
      <button class="modal-close" type="button" data-modal-dismiss>&times;</button>
      <h2 class="modal-title" id="driverModalTitle">Motorista</h2>
      <form id="driverDetailForm">
        <p class="small muted" id="driverDetailHint">Edite os campos abaixo e salve para atualizar a planilha.</p>
        <div class="modal-body">
          <div class="form-grid" id="driverDetailFields"></div>
        </div>
        <div class="modal-actions">
          <button type="button" class="btn" data-modal-dismiss>Cancelar</button>
          <button type="submit" class="btn btn--primary" id="driverDetailSubmit">Salvar</button>
        </div>
      </form>
    </div>
  </div>

  <div class="modal hidden" id="driverFormModal" aria-hidden="true">
    <div class="modal-backdrop" data-modal-dismiss></div>
    <div class="modal-card">
      <button class="modal-close" type="button" data-modal-dismiss>&times;</button>
      <h2 class="modal-title">Adicionar motorista</h2>
      <form id="driverForm">
        <p class="small muted" id="driverFormHint">Preencha os campos abaixo para adicionar um motorista a esta campanha.</p>
        <div class="form-grid" id="driverFormFields"></div>
        <div class="modal-actions">
          <button type="button" class="btn" data-modal-dismiss>Cancelar</button>
          <button type="submit" class="btn btn--primary" id="driverFormSubmit">Salvar</button>
        </div>
      </form>
    </div>
  </div>


  <!-- KM Edit Modal -->
  <div class="modal hidden" id="kmEditModal" aria-hidden="true">
    <div class="modal-backdrop" data-modal-dismiss></div>
    <div class="modal-card">
      <button class="modal-close" type="button" data-modal-dismiss>&times;</button>
      <h2 class="modal-title">Editar KM / Metas</h2>
      <form id="kmEditForm">
        <p class="small muted" id="kmEditHint">Edite os campos da linha de KM e salve para atualizar a planilha.</p>
        <div class="modal-body">
          <div class="form-grid" id="kmEditFields"></div>
        </div>
        <div class="modal-actions">
          <button type="button" class="btn" data-modal-dismiss>Cancelar</button>
          <button type="submit" class="btn btn--primary" id="kmEditSubmit">Salvar KM</button>
        </div>
      </form>
    </div>
  </div>

  <script src="js/campaign.js"></script>
</body>
</html>


=== FILE: frontend\index.html ===

<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OD Drive - Admin</title>
  <link rel="stylesheet" href="assets/styles.css" />
</head>
<body>
  <!-- Topbar -->
  <div class="topbar">
    <div class="wrap">
      <div class="brand">
        <!-- Se quiser, coloque seu logo aqui -->
        <h1>Campanhas</h1>
      </div>
      <div class="actions">
        <button class="btn" id="btnAdd">Adicionar campanha</button>
        <button class="btn btn--primary" id="btnImport">Importar planilha</button>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Chips de filtro -->
    <div class="chips" id="chips">
      <button class="chip active" data-filter="ativa">Ativas</button>
      <button class="chip" data-filter="pausada">Pausadas</button>
      <button class="chip" data-filter="encerrada">Encerradas</button>
      <button class="chip" data-filter="*">Todas</button>
    </div>

    <!-- Cards -->
    <section id="cards" class="grid-cards">
      <div class="card placeholder">
        <div class="card-head">
          <h3 class="m0">Nenhuma campanha</h3>
          <span class="pill">Importar planilha</span>
        </div>
        <p class="small m0">Use "Importar planilha" para criar uma campanha a partir da aba Pagina1.</p>
      </div>
    </section>

    <p class="small mt16">Dica: use "Importar planilha" para criar campanhas a partir da aba Pagina1 (status desconhecido vai para <b>Revisar</b>).</p>
  </div>

  <script src="js/app.js"></script>
</body>
</html>


=== FILE: frontend\js\app.js ===

const cardsEl = document.getElementById('cards');
const chipsEl = document.getElementById('chips');
const btnAdd = document.getElementById('btnAdd');
const btnImport = document.getElementById('btnImport');

let campaignsCache = [];
let activeFilter = 'ativa';

function escapeHTML(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

async function fetchJSON(url, opts) {
  const res = await fetch(url, opts);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(text || `HTTP ${res.status}`);
  }
  return res.json();
}

function formatStatus(status) {
  const value = String(status || '').toLowerCase();
  if (!value) return '-';
  return value.charAt(0).toUpperCase() + value.slice(1);
}

function renderCampaigns() {
  const filtered =
    activeFilter === '*'
      ? campaignsCache
      : campaignsCache.filter(
          campaign => String(campaign.status || '').toLowerCase() === activeFilter,
        );

  cardsEl.innerHTML = '';

  if (!filtered.length) {
    const placeholder = document.createElement('article');
    placeholder.className = 'card placeholder';
    placeholder.innerHTML = `
      <div class="card-head">
        <h3 class="m0">Nenhuma campanha</h3>
        <span class="pill">Importar planilha</span>
      </div>
      <p class="small m0">Ainda nao ha campanhas para este filtro.</p>
    `;
    cardsEl.appendChild(placeholder);
    return;
  }

  for (const campaign of filtered) {
    const counts = campaign.counts || {};
    const reviewCount = counts.revisar || campaign.reviewCount || 0;
    const card = document.createElement('article');
    card.className = 'card';
    const canSync = Boolean(campaign.sheetId);

    const clientInfo = [
      campaign.client && escapeHTML(campaign.client),
      campaign.period && escapeHTML(campaign.period),
    ]
      .filter(Boolean)
      .join(' &middot; ');

    card.innerHTML = `
      <div class="card-head">
        <h3 class="m0">${escapeHTML(campaign.name)}</h3>
        <span class="pill${reviewCount > 0 ? ' warn' : ''}">${formatStatus(
          campaign.status,
        )}</span>
      </div>
      <div class="card-meta">${clientInfo || 'Sem cliente/periodo'}</div>
      <div class="counts">
        <div class="count">Agendado: ${counts.agendado || 0}</div>
        <div class="count">Confirmado: ${counts.confirmado || 0}</div>
        <div class="count">Instalado: ${counts.instalado || 0}</div>
        <div class="count">Revisar: ${reviewCount}</div>
      </div>
      <div class="card-actions">
        <a class="btn btn--primary" href="campaign.html?id=${encodeURIComponent(
          campaign.id,
        )}">Ver detalhes</a>
        <button class="btn btn--ghost" data-action="sync" data-id="${encodeURIComponent(
          campaign.id,
        )}" ${canSync ? '' : 'disabled title="Sem planilha vinculada"'}>Sincronizar</button>
        <button class="btn btn--danger" data-action="delete" data-id="${encodeURIComponent(
          campaign.id,
        )}">Excluir</button>
      </div>
    `;

    cardsEl.appendChild(card);
  }
}

async function loadCampaigns() {
  try {
    const data = await fetchJSON('/api/campaigns');
    campaignsCache = Array.isArray(data) ? data : [];
    renderCampaigns();
  } catch (err) {
    console.error(err);
    alert('Nao foi possivel carregar as campanhas.');
  }
}

function setActiveFilter(filter) {
  activeFilter = filter;
  renderCampaigns();
}

function setupFilters() {
  if (!chipsEl) return;
  chipsEl.addEventListener('click', event => {
    const button = event.target.closest('.chip');
    if (!button) return;

    chipsEl.querySelectorAll('.chip').forEach(chip => chip.classList.remove('active'));
    button.classList.add('active');

    setActiveFilter(button.dataset.filter || '*');
  });
}

async function handleCreateCampaign() {
  const name = prompt('Nome da campanha:');
  if (!name) return;

  const client = prompt('Cliente (opcional):') || '';
  const period = prompt('Periodo (ex: Jul-Set) (opcional):') || '';

  try {
    await fetchJSON('/api/campaigns', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, client, period }),
    });
    await loadCampaigns();
  } catch (err) {
    console.error(err);
    alert('Nao foi possivel criar a campanha.');
  }
}

async function handleImportCampaign() {
  const spreadsheetId = prompt('ID da planilha da campanha (Google Sheets):');
  if (!spreadsheetId) return;

  const campaignName = prompt('Nome da campanha (como aparecera no painel):') || '';
  const client = prompt('Cliente (opcional):') || '';
  const period = prompt('Periodo (ex: Jul-Set) (opcional):') || '';
  const sheetName = prompt('Nome da aba (padrao Pagina1):', 'Pagina1') || 'Pagina1';

  btnImport.disabled = true;
  btnImport.textContent = 'Importando...';

  try {
    const payload = {
      spreadsheetId: spreadsheetId.trim(),
      sheetName: sheetName.trim(),
      campaignName: campaignName.trim(),
      client: client.trim(),
      period: period.trim(),
    };

    const result = await fetchJSON('/api/imports/campaign', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    alert(
      `Importacao concluida.\nMotoristas validos: ${result.imported}\n` +
        `Itens para revisar: ${result.review}`,
    );
    await loadCampaigns();
  } catch (err) {
    console.error(err);
    alert('Nao foi possivel importar a planilha. Verifique o ID e tente novamente.');
  } finally {
    btnImport.disabled = false;
    btnImport.textContent = 'Importar planilha';
  }
}

document.addEventListener('DOMContentLoaded', () => {
  setupFilters();
  loadCampaigns();

  if (cardsEl) {
    cardsEl.addEventListener('click', async event => {
      const button = event.target.closest('button[data-action]');
      if (!button) return;

      const id = button.dataset.id;
      if (!id) return;

      if (button.dataset.action === 'sync') {
        event.preventDefault();
        if (button.disabled) return;
        const original = button.textContent;
        const previousDisabled = button.disabled;
        try {
          button.disabled = true;
          button.textContent = 'Sincronizando...';
          await fetchJSON(`/api/campaigns/${id}/sync`, { method: 'POST' });
          await loadCampaigns();
          alert('Campanha sincronizada com sucesso.');
        } catch (err) {
          console.error(err);
          alert('Nao foi possivel sincronizar a campanha.');
        } finally {
          if (document.body.contains(button)) {
            button.textContent = original;
            button.disabled = previousDisabled;
          }
        }
      }

      if (button.dataset.action === 'delete') {
        event.preventDefault();
        if (!confirm('Tem certeza que deseja excluir esta campanha? Essa acao nao pode ser desfeita.')) {
          return;
        }
        const original = button.textContent;
        const previousDisabled = button.disabled;
        try {
          button.disabled = true;
          button.textContent = 'Excluindo...';
          const res = await fetch(`/api/campaigns/${id}`, { method: 'DELETE' });
          if (!res.ok) {
            const text = await res.text();
            throw new Error(text || `HTTP ${res.status}`);
          }
          await loadCampaigns();
        } catch (err) {
          console.error(err);
          alert('Nao foi possivel excluir a campanha.');
          if (document.body.contains(button)) {
            button.disabled = previousDisabled;
          }
        } finally {
          if (document.body.contains(button)) {
            button.textContent = original;
          }
        }
      }
    });
  }

  if (btnAdd) {
    btnAdd.addEventListener('click', handleCreateCampaign);
  }

  if (btnImport) {
    btnImport.addEventListener('click', handleImportCampaign);
  }
});


=== FILE: frontend\js\campaign.js ===

const urlParams = new URLSearchParams(window.location.search);
const campaignId = urlParams.get('id');

const tabs = document.querySelectorAll('.tab');
const panels = document.querySelectorAll('.tab-panel');
const btnSync = document.getElementById('btnSync');
const btnDelete = document.getElementById('btnDelete');
const btnAddDriver = document.getElementById('btnAddDriver');
const btnSaveDrivers = document.getElementById('btnSaveDrivers');
const btnImportKm = document.getElementById("btnImportKm");
const tblDrivers = document.getElementById('tblDrivers');
const driverDetailModal = document.getElementById('driverDetailModal');
const driverModalTitle = document.getElementById('driverModalTitle');
const driverDetailForm = document.getElementById('driverDetailForm');
const driverDetailFields = document.getElementById('driverDetailFields');
const driverDetailSubmit = document.getElementById('driverDetailSubmit');
const driverDetailHint = document.getElementById('driverDetailHint');
const driverFormModal = document.getElementById('driverFormModal');
const driverForm = document.getElementById('driverForm');
const driverFormFields = document.getElementById('driverFormFields');
const driverFormSubmit = document.getElementById('driverFormSubmit');
const driverFormHint = document.getElementById('driverFormHint');
const campaignStatusSelect = document.getElementById('campaignStatus');

const el = selector => document.querySelector(selector);
 
// globals that were accidentally removed
let currentCampaign = null;
let openModalCount = 0;
const STATUS_OPTIONS = ['agendado','confirmado','instalado','aguardando','cadastrando','problema','revisar'];
const CAMPAIGN_STATUS_OPTIONS = ['ativa','pausada','encerrada','inativa'];
const pendingDriverChanges = new Map();

function normalizeKey(key) {
  return String(key || '')
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .toLowerCase();
}

function escapeHTML(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function findColumnKey(targets) {
  const header = getCampaignHeader();
  if (!Array.isArray(header) || header.length === 0) return null;
  const list = Array.isArray(targets) ? targets : [targets];
  const normalizedTargets = list.map(normalizeKey);
  return header.find(col => normalizedTargets.includes(normalizeKey(col))) || null;
}

const kmNumberFormatter = new Intl.NumberFormat('pt-BR', { maximumFractionDigits: 0 });
const percentNumberFormatter = new Intl.NumberFormat('pt-BR', { maximumFractionDigits: 0 });

function formatKmValue(value) {
  if (value === null || value === undefined || value === '') return '-';
  if (typeof value === 'number' && Number.isFinite(value)) return kmNumberFormatter.format(value);
  const parsed = Number(String(value).replace(/\./g, '').replace(/,/g, '.'));
  return Number.isFinite(parsed) ? kmNumberFormatter.format(parsed) : String(value);
}

function formatPercentValue(value) {
  if (value === null || value === undefined || !Number.isFinite(Number(value))) return '-';
  return `${percentNumberFormatter.format(Number(value))}%`;
}

function formatNumber(value) {
  if (value === null || value === undefined || value === '') return '-';
  if (typeof value === 'number' && Number.isFinite(value)) return value.toLocaleString('pt-BR');
  const parsed = Number(String(value).replace(/\./g, '').replace(/,/g, '.'));
  return Number.isFinite(parsed) ? parsed.toLocaleString('pt-BR') : String(value);
}
 
function normalizeDriverStatus(value) {
  const status = normalizeKey(value);
  if (!status) return '';
  const map = {
    agendada: 'agendado',
    confirmada: 'confirmado',
    instalada: 'instalado',
    pendente: 'aguardando',
    'em cadastro': 'cadastrando',
  };
  const normalized = map[status] || status;
  return STATUS_OPTIONS.includes(normalized) ? normalized : status;
}

function showModal(modal) {
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  openModalCount += 1;
  document.body.style.overflow = 'hidden';
}

function hideModal(modal) {
  if (!modal) return;
  if (!modal.classList.contains('hidden')) {
    modal.classList.add('hidden');
    modal.setAttribute('aria-hidden', 'true');
    openModalCount = Math.max(0, openModalCount - 1);
    if (openModalCount === 0) document.body.style.overflow = '';
  }
  if (modal === driverFormModal && driverForm) {
    driverForm.reset();
  }
  if (modal === driverDetailModal && driverDetailForm) {
    driverDetailForm.reset();
  }
}

function formatStatusPill(value) {
  const status = String(value || '').toLowerCase();
  if (!status) return { label: '-', className: '' };
  const label = status.charAt(0).toUpperCase() + status.slice(1);
  return { label, className: status };
}

function ensureTableState(table) {
  if (!table) return;
  const body = table.querySelector('tbody');
  const emptyMessage = table.dataset.empty || 'Sem registros.';
  if (!body) return;

  if (body.children.length === 0) {
    const row = document.createElement('tr');
    const cell = document.createElement('td');
    cell.colSpan = table.querySelectorAll('th').length || 1;
    cell.className = 'empty-row';
    cell.textContent = emptyMessage;
    row.appendChild(cell);
    body.appendChild(row);
  }
}

function markDriverRowDirty(driverId, dirty) {
  if (!tblDrivers || !driverId) return;
  const row = tblDrivers.querySelector(
    `tr[data-driver-id="${escapeSelector(driverId)}"]`,
  );
  if (row) row.classList.toggle('pending-row', dirty);
}

function updateSaveButtonState() {
  if (!btnSaveDrivers) return;
  btnSaveDrivers.disabled = pendingDriverChanges.size === 0;
}

function bufferDriverChange(driverId, column, value, originalValue = '') {
  if (!driverId || !column) return;
  const trimmed = value;
  const current = pendingDriverChanges.get(driverId) || {};

  if (trimmed === (originalValue ?? '')) {
    delete current[column];
    if (Object.keys(current).length === 0) {
      pendingDriverChanges.delete(driverId);
      markDriverRowDirty(driverId, false);
    } else {
      pendingDriverChanges.set(driverId, current);
    }
  } else {
    current[column] = trimmed;
    pendingDriverChanges.set(driverId, current);
    markDriverRowDirty(driverId, true);
  }

  updateSaveButtonState();
}

async function fetchCampaign(id) {
  const url = `/api/campaigns/${encodeURIComponent(id)}`;
  console.debug('fetchCampaign url=', url);
  const res = await fetch(url);
  if (!res.ok) {
    let message = '';
    try { message = await res.text(); } catch (e) { message = String(e); }
    const err = new Error(message || `HTTP ${res.status}`);
    err.status = res.status;
    err.responseText = message;
    throw err;
  }
  return res.json();
}

function renderCounts(counts = {}) {
  el('#cAg').textContent = counts.agendado || 0;
  el('#cCf').textContent = counts.confirmado || 0;
  el('#cIn').textContent = counts.instalado || 0;
  el('#cPb').textContent = counts.problema || 0;
  el('#cRv').textContent = counts.revisar || 0;
}

function renderDrivers(drivers = []) {
  const tbody = tblDrivers;
  if (!tbody) return;
  tbody.innerHTML = '';
  pendingDriverChanges.clear();
  updateSaveButtonState();

  // sort drivers alphabetically (pt-BR) by name for consistent UI
  const collator = new Intl.Collator('pt-BR', { sensitivity: 'base', ignorePunctuation: true });
  const sortedDrivers = Array.isArray(drivers) ? [...drivers].sort((a, b) => collator.compare((a.name||''), (b.name||''))) : [];

  const columnCity = findColumnKey(['cidade', 'city']);
  const columnStatus = findColumnKey(['status']);
  const columnAdh = findColumnKey(['aderencia']);
  for (const driver of sortedDrivers) {
    const row = document.createElement('tr');
    row.dataset.driverId = driver.id || '';

    // Nome
    const nameCell = document.createElement('td');
    const nameButton = document.createElement('button');
    nameButton.type = 'button';
    nameButton.className = 'link-button driver-name';
    nameButton.dataset.driverId = driver.id || '';
    nameButton.textContent = driver.name || '-';
    nameCell.appendChild(nameButton);
    row.appendChild(nameCell);

    // Cidade
    const cityCell = document.createElement('td');
    const originalCity =
      (driver.raw && columnCity ? driver.raw[columnCity] : null) ||
      driver.city ||
      '';
    if (columnCity) {
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'driver-input';
      input.value = originalCity;
      input.dataset.originalValue = originalCity;
      input.addEventListener('input', () =>
        bufferDriverChange(
          driver.id,
          columnCity,
          input.value,
          input.dataset.originalValue,
        ),
      );
      cityCell.appendChild(input);
    } else {
      cityCell.textContent = originalCity || '-';
    }
    row.appendChild(cityCell);

    // Status
    const statusCell = document.createElement('td');
    const rawStatus =
      (driver.raw && columnStatus ? driver.raw[columnStatus] : null) ||
      driver.status ||
      '';
    if (columnStatus) {
      const select = document.createElement('select');
      select.className = 'driver-input';
      STATUS_OPTIONS.forEach(status => {
        const option = document.createElement('option');
        option.value = status;
        option.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        select.appendChild(option);
      });
      const normalizedStatus = normalizeDriverStatus(rawStatus);
      const originalStatus =
        (STATUS_OPTIONS.includes(normalizedStatus) && normalizedStatus) ||
        rawStatus ||
        'agendado';
      if (!STATUS_OPTIONS.includes(originalStatus)) {
        const option = document.createElement('option');
        option.value = originalStatus;
        option.textContent =
          originalStatus.charAt(0).toUpperCase() + originalStatus.slice(1);
        select.appendChild(option);
      }
      select.value = originalStatus;
      select.dataset.originalValue = originalStatus;
      select.addEventListener('change', () =>
        bufferDriverChange(
          driver.id,
          columnStatus,
          select.value,
          select.dataset.originalValue,
        ),
      );
      statusCell.appendChild(select);
    } else {
      const pill = document.createElement('span');
      const statusInfo = formatStatusPill(rawStatus);
      pill.className = `status ${statusInfo.className}`;
      pill.textContent = statusInfo.label;
      statusCell.appendChild(pill);
    }
    row.appendChild(statusCell);

    // Aderencia
    const adhCell = document.createElement('td');
    const originalAdh =
      (driver.raw && columnAdh ? driver.raw[columnAdh] : null) ||
      driver.adh ||
      '';
    if (columnAdh) {
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'driver-input';
      input.value = originalAdh;
      input.dataset.originalValue = originalAdh;
      input.addEventListener('input', () =>
        bufferDriverChange(
          driver.id,
          columnAdh,
          input.value,
          input.dataset.originalValue,
        ),
      );
      adhCell.appendChild(input);
    } else {
      adhCell.textContent = originalAdh || '-';
    }
    row.appendChild(adhCell);

    // KM
    const kmCell = document.createElement('td');
    kmCell.textContent = formatKmValue(driver.km?.total?.kmRodado ?? null);
    row.appendChild(kmCell);

    // Acoes
    const actionsCell = document.createElement('td');
    const deleteButton = document.createElement('button');
    deleteButton.type = 'button';
    deleteButton.className = 'btn btn--ghost driver-action-delete';
    deleteButton.dataset.driverId = driver.id || '';
    deleteButton.textContent = 'Excluir';
    actionsCell.appendChild(deleteButton);
    row.appendChild(actionsCell);

    tbody.appendChild(row);
  }

  ensureTableState(tbody.closest('table'));
}

function renderKm(drivers = []) {
  const tbody = el('#tblKm');
  if (!tbody) return;
  tbody.innerHTML = '';
  const header = Array.isArray(currentCampaign?.kmSheetHeader) && currentCampaign.kmSheetHeader.length
    ? currentCampaign.kmSheetHeader
    : (Array.isArray(currentCampaign?.sheetHeader) && currentCampaign.sheetHeader.length ? currentCampaign.sheetHeader : []);

  // sort drivers alphabetically (pt-BR) by name for consistent UI
  const collator = new Intl.Collator('pt-BR', { sensitivity: 'base', ignorePunctuation: true });
  const sortedDrivers = Array.isArray(drivers) ? [...drivers].sort((a, b) => collator.compare((a.name||''), (b.name||''))) : [];

  for (const driver of sortedDrivers) {
    // Ensure we render every driver even if they don't have KM data yet
    let kmData = driver.km;
    if (!kmData) {
      kmData = {
        periods: [],
        total: { kmRodado: '', metaKm: '', percent: null, status: '', label: 'Total', isTotal: true },
        checkIn: '',
        comentarios: '',
        observacoes: '',
      };
    }

    const periods = Array.isArray(kmData.periods)
      ? kmData.periods.map(period => ({ ...period, label: `Periodo ${period.index}` }))
      : [];

    const totalRows = kmData.total
      ? [{ ...kmData.total, label: 'Total', isTotal: true, checkIn: kmData.checkIn || '', comentarios: kmData.comentarios || '', observacoes: kmData.observacoes || '' }]
      : [];

    const rows = [...periods, ...totalRows];

    rows.forEach((period, index) => {
      const tr = document.createElement('tr');

      if (index === 0) {
        const nameCell = document.createElement('td');
        nameCell.rowSpan = rows.length;
        const nameButton = document.createElement('button');
        nameButton.type = 'button';
        nameButton.className = 'link-button km-name';
        nameButton.dataset.driverId = driver.id || '';
        nameButton.textContent = driver.name || '-';
        nameCell.appendChild(nameButton);
        tr.appendChild(nameCell);
      }

  const periodCell = document.createElement('td');
  // keep period label and number on the same line to avoid vertical stacking
  periodCell.className = 'period-cell';
  periodCell.textContent = period.label || `Periodo ${period.index || ''}`;
      tr.appendChild(periodCell);

      // KM (editable)
      const kmCell = document.createElement('td');
      const kmInput = document.createElement('input');
      kmInput.type = 'text';
      kmInput.className = 'driver-input';
      kmInput.value = period.kmRodado ?? '';
      kmInput.dataset.driverId = driver.id;
      kmInput.dataset.column = `KM RODADO ${period.index || (period.label === 'Total' ? 'TOTAL' : '')}`;
      kmInput.addEventListener('change', async (e) => {
        const value = e.target.value;
        const driverId = e.target.dataset.driverId;
        const col = e.target.dataset.column;
        try {
          const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`, {
            method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fields: { [col]: value } }),
          });
          if (!res.ok) { const text = await res.text(); throw new Error(text || `HTTP ${res.status}`); }
          await init();
        } catch (err) { console.error(err); alert('Nao foi possivel atualizar KM'); }
      });
      kmCell.appendChild(kmInput);
      tr.appendChild(kmCell);

      // Meta (editable)
      const metaCell = document.createElement('td');
      const metaInput = document.createElement('input');
      metaInput.type = 'text';
      metaInput.className = 'driver-input';
      metaInput.value = period.metaKm ?? '';
      metaInput.dataset.driverId = driver.id;
      metaInput.dataset.column = `META KM ${period.index || (period.label === 'Total' ? 'TOTAL' : '')}`;
      metaInput.addEventListener('change', async (e) => {
        const value = e.target.value;
        const driverId = e.target.dataset.driverId;
        const col = e.target.dataset.column;
        try {
          const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`, {
            method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fields: { [col]: value } }),
          });
          if (!res.ok) { const text = await res.text(); throw new Error(text || `HTTP ${res.status}`); }
          await init();
        } catch (err) { console.error(err); alert('Nao foi possivel atualizar Meta KM'); }
      });
      metaCell.appendChild(metaInput);
      tr.appendChild(metaCell);

      const percentCell = document.createElement('td');
      percentCell.textContent = formatPercentValue(period.percent ?? null);
      tr.appendChild(percentCell);

      const statusCell = document.createElement('td');
      const statusInput = document.createElement('input');
      statusInput.type = 'text';
      statusInput.className = 'driver-input';
      statusInput.value = period.status ?? '';
      statusInput.dataset.driverId = driver.id;
      statusInput.dataset.column = period.isTotal ? 'STATUS TOTAL' : `STATUS ${period.index || ''}`;
      statusInput.addEventListener('change', async (e) => {
        const value = e.target.value;
        const driverId = e.target.dataset.driverId;
        const col = e.target.dataset.column;
        try {
          const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`, {
            method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fields: { [col]: value } }),
          });
          if (!res.ok) { const text = await res.text(); throw new Error(text || `HTTP ${res.status}`); }
          await init();
        } catch (err) { console.error(err); alert('Nao foi possivel atualizar Status'); }
      });
      statusCell.appendChild(statusInput);
      tr.appendChild(statusCell);

      const checkCell = document.createElement('td');
      if (period.isTotal) {
        const checkInput = document.createElement('input');
        checkInput.type = 'text';
        checkInput.className = 'driver-input';
        checkInput.value = kmData.checkIn || '';
        checkInput.dataset.driverId = driver.id;
        checkInput.dataset.column = 'CHECK IN';
        checkInput.addEventListener('change', async (e) => {
          const value = e.target.value;
          const driverId = e.target.dataset.driverId;
          const col = e.target.dataset.column;
          try {
            const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`, {
              method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fields: { [col]: value } }),
            });
            if (!res.ok) { const text = await res.text(); throw new Error(text || `HTTP ${res.status}`); }
            await init();
          } catch (err) { console.error(err); alert('Nao foi possivel atualizar Check-in'); }
        });
        checkCell.appendChild(checkInput);
      } else {
        checkCell.textContent = '';
      }
      tr.appendChild(checkCell);

      const notesCell = document.createElement('td');
      if (period.isTotal) {
        const notesInput = document.createElement('textarea');
        notesInput.className = 'driver-input';
        notesInput.value = [kmData.comentarios, kmData.observacoes].filter(v => v).join('\n') || '';
        notesInput.dataset.driverId = driver.id;
        notesInput.dataset.column = 'COMENTÃRIOS';
        notesInput.addEventListener('change', async (e) => {
          const value = e.target.value;
          const driverId = e.target.dataset.driverId;
          const col = e.target.dataset.column;
          try {
            const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`, {
              method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fields: { [col]: value } }),
            });
            if (!res.ok) { const text = await res.text(); throw new Error(text || `HTTP ${res.status}`); }
            await init();
          } catch (err) { console.error(err); alert('Nao foi possivel atualizar Comentarios'); }
        });
        notesCell.appendChild(notesInput);
      } else {
        notesCell.textContent = '';
      }
      tr.appendChild(notesCell);

      tbody.appendChild(tr);
    });
  }

  ensureTableState(tbody.closest('table'));
}

// renderKmCards removed; using table layout but with editable inputs instead

function renderKmEditForm(driver) {
  const form = document.getElementById('kmEditForm');
  const container = document.getElementById('kmEditFields');
  const hint = document.getElementById('kmEditHint');
  if (!form || !container) return;
  container.innerHTML = '';

  const header = Array.isArray(currentCampaign?.kmSheetHeader) && currentCampaign.kmSheetHeader.length
    ? currentCampaign.kmSheetHeader
    : Array.isArray(currentCampaign?.sheetHeader) && currentCampaign.sheetHeader.length
    ? currentCampaign.sheetHeader
    : Object.keys(driver?.km?.raw || {}).filter(k => !String(k).startsWith('_'));

  const raw = driver?.km?.raw || {};
  if (hint) {
    hint.textContent = driver.rowNumber ? `Linha ${driver.rowNumber} da planilha.` : 'Edite os campos abaixo e salve para atualizar a planilha.';
  }

  if (!header || !header.length) {
    const p = document.createElement('p');
    p.className = 'small muted';
    p.textContent = 'Sem colunas definidas para esta planilha.';
    container.appendChild(p);
    return;
  }

  header.forEach((column, index) => {
    if (!column) return;
    const group = document.createElement('div');
    group.className = 'form-group';

    const label = document.createElement('label');
    label.setAttribute('for', `km-field-${index}`);
    label.textContent = column;

    const field = createInputForColumn(column, index, 'km-field');
    const currentValue = raw[column] ?? '';
    field.value = currentValue;
    field.dataset.originalValue = currentValue;
    group.append(label, field);
    container.appendChild(group);
  });

  form.dataset.driverId = driver.id || '';
}

function openKmEdit(driverId) {
  const driver = getDriverById(driverId);
  if (!driver) {
    alert('Motorista nao encontrado.');
    return;
  }
  renderKmEditForm(driver);
  showModal(document.getElementById('kmEditModal'));
}

function renderReview(items = []) {
  const tbody = el('#tblReview');
  if (!tbody) return;
  tbody.innerHTML = '';

  for (const item of items) {
    const row = document.createElement('tr');
    row.dataset.reviewId = item.id || '';
    row.dataset.reviewType = item.type || '';
    if (item.driverId) row.dataset.driverId = item.driverId;

    const typeCell = document.createElement('td');
    typeCell.textContent = item.type || '-';
    row.appendChild(typeCell);

    const descCell = document.createElement('td');
    const lines = [];
    if (item.driverName) {
      lines.push(`<strong>${escapeHTML(item.driverName)}</strong>`);
    }
    if (item.column) {
      const value = item.value ? escapeHTML(item.value) : '<i>(vazio)</i>';
      lines.push(`${escapeHTML(item.column)}: ${value}`);
    }
    if (item.rowNumber) {
      lines.push(`Linha ${item.rowNumber}`);
    }
    if (item.note) {
      lines.push(escapeHTML(item.note));
    }
    if (item.payload && item.type === 'KM_MATCH') {
      const nome = item.payload.raw?.Nome || item.payload.raw?.NOME || '';
      const kmTotal = item.payload.kmTotal || '';
      lines.push(`Nome informado: ${escapeHTML(nome)}`);
      if (kmTotal) lines.push(`KM Total: ${escapeHTML(kmTotal)}`);
    }
    descCell.innerHTML = lines.length ? lines.join('<br/>') : 'Sem detalhes';
    row.appendChild(descCell);

    const actionCell = document.createElement('td');
    actionCell.className = 'review-actions';
    const canApplyStatus = item.type === 'STATUS_INVALIDO' && item.driverId;
    if (canApplyStatus) {
      const select = document.createElement('select');
      select.className = 'driver-input review-status-select';
      STATUS_OPTIONS.forEach(status => {
        const option = document.createElement('option');
        option.value = status;
        option.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        select.appendChild(option);
      });
      const normalized = normalizeDriverStatus(item.value);
      select.value = STATUS_OPTIONS.includes(normalized) ? normalized : 'agendado';
      actionCell.appendChild(select);

      const applyBtn = document.createElement('button');
      applyBtn.type = 'button';
      applyBtn.className = 'btn btn--primary review-action';
      applyBtn.textContent = 'Aplicar';
      applyBtn.dataset.reviewAction = 'apply-status';
      applyBtn.dataset.reviewId = item.id || '';
      actionCell.appendChild(applyBtn);
    }

    const ignoreBtn = document.createElement('button');
    ignoreBtn.type = 'button';
    ignoreBtn.className = 'btn btn--ghost review-action';
    ignoreBtn.textContent = 'Ignorar';
    ignoreBtn.dataset.reviewAction = 'ignore';
    ignoreBtn.dataset.reviewId = item.id || '';
    actionCell.appendChild(ignoreBtn);

    row.appendChild(actionCell);
    tbody.appendChild(row);
  }

  ensureTableState(tbody.closest('table'));
}

function getDriverById(id) {
  if (!currentCampaign || !Array.isArray(currentCampaign.drivers)) return null;
  return currentCampaign.drivers.find(d => d.id === id);
}

function renderDriverDetails(driver) {
  if (!driverModalTitle || !driverDetailFields || !driverDetailForm) return;
  driverModalTitle.textContent = driver.name || 'Motorista';
  driverDetailForm.dataset.driverId = driver.id || '';
  driverDetailFields.innerHTML = '';

  const header = getCampaignHeader();
  const raw = driver.raw || {};
  const entries = header.length
    ? header.map(col => [col, raw[col] ?? ''])
    : Object.entries(raw).filter(([key]) => key && !String(key).startsWith('_'));

  if (!entries.length) {
    const message = document.createElement('p');
    message.className = 'small muted';
    message.textContent = 'Sem dados complementares para este motorista.';
    driverDetailFields.appendChild(message);
    return;
  }

  if (driverDetailHint) {
    driverDetailHint.textContent = driver.rowNumber
      ? `Linha ${driver.rowNumber} da planilha.`
      : 'Edite os campos abaixo e salve para atualizar a planilha.';
  }

  entries.forEach(([column, value], index) => {
    const group = document.createElement('div');
    group.className = 'form-group';

    const label = document.createElement('label');
    label.setAttribute('for', `driver-detail-field-${index}`);
    label.textContent = column;

    const field = createInputForColumn(column, index, 'driver-detail-field');
    const currentValue = value ?? '';
    field.value = currentValue;
    field.dataset.originalValue = currentValue;
    if (field.tagName === 'SELECT') {
      const exists = Array.from(field.options).some(opt => opt.value === field.value);
      if (!exists && field.value) {
        const option = document.createElement('option');
        option.value = field.value;
        option.textContent = field.value;
        field.appendChild(option);
      }
      field.value = field.value || 'agendado';
    }

    group.append(label, field);
    driverDetailFields.appendChild(group);
  });
}

function openDriverDetail(driverId) {
  const driver = getDriverById(driverId);
  if (!driver) {
    alert('Motorista nao encontrado.');
    return;
  }
  renderDriverDetails(driver);
  showModal(driverDetailModal);
}

function getCampaignHeader() {
  if (
    currentCampaign &&
    Array.isArray(currentCampaign.sheetHeader) &&
    currentCampaign.sheetHeader.length
  ) {
    return currentCampaign.sheetHeader;
  }

  if (currentCampaign?.drivers?.length) {
    const raw = currentCampaign.drivers[0].raw || {};
    return Object.keys(raw).filter(key => key && !String(key).startsWith('_'));
  }

  return ['Nome', 'Cidade', 'Status', 'PIX'];
}

function createInputForColumn(column, index, prefix = 'driver-field') {
  const lower = column.toLowerCase();
  const id = `${prefix}-${index}`;
  let field;

  if (lower === 'status') {
    field = document.createElement('select');
    STATUS_OPTIONS.forEach(value => {
      const option = document.createElement('option');
      option.value = value;
      option.textContent = value.charAt(0).toUpperCase() + value.slice(1);
      field.appendChild(option);
    });
    field.value = 'agendado';
  } else if (lower.includes('observ') || lower.includes('coment')) {
    field = document.createElement('textarea');
  } else {
    field = document.createElement('input');
    field.type = 'text';
  }

  field.id = id;
  field.dataset.column = column;
  if (lower === 'nome') {
    field.required = true;
  }
  return field;
}

function renderDriverFormFields() {
  if (!driverFormFields) return;
  driverFormFields.innerHTML = '';
  const header = getCampaignHeader();

  header.forEach((column, index) => {
    if (!column) return;
    const group = document.createElement('div');
    group.className = 'form-group';

    const label = document.createElement('label');
    label.setAttribute('for', `driver-field-${index}`);
    label.textContent = column;

    const field = createInputForColumn(column, index);

    group.append(label, field);
    driverFormFields.appendChild(group);
  });

  if (driverFormHint) {
    driverFormHint.textContent = 'Campos vazios serao gravados em branco. Nome Ã© obrigatorio.';
  }
}

function parseNumeric(value) {
  if (value == null) return 0;
  const normalized = String(value)
    .replace(/\./g, '')
    .replace(',', '.')
    .replace(/[^\d.-]/g, '');
  const parsed = parseFloat(normalized);
  return Number.isFinite(parsed) ? parsed : 0;
}

function calculateMetrics(drivers = []) {
  let totalKm = 0;
  for (const driver of drivers) {
    const kmTotal = driver?.km?.total?.kmRodado;
    if (kmTotal !== null && kmTotal !== undefined) {
      totalKm += parseNumeric(kmTotal);
    }
  }
  return { totalKm };
}
async function savePendingDriverChanges() {
  if (!btnSaveDrivers) return;
  if (pendingDriverChanges.size === 0) {
    alert('Nenhuma alteracao pendente.');
    return;
  }

  const originalLabel = btnSaveDrivers.textContent;
  btnSaveDrivers.disabled = true;
  btnSaveDrivers.textContent = 'Salvando...';

  try {
    const entries = Array.from(pendingDriverChanges.entries());
    for (const [driverId, fields] of entries) {
      const res = await fetch(
        `/api/campaigns/${encodeURIComponent(campaignId)}/drivers/${encodeURIComponent(driverId)}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fields }),
        },
      );
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `HTTP ${res.status}`);
      }
      pendingDriverChanges.delete(driverId);
      markDriverRowDirty(driverId, false);
    }
    await init();
    alert('Alteracoes salvas com sucesso.');
  } catch (err) {
    console.error(err);
    alert('Nao foi possivel salvar as alteracoes.');
  } finally {
    btnSaveDrivers.textContent = originalLabel;
    updateSaveButtonState();
  }
}

function populateSummary(campaign, metrics = {}) {
  currentCampaign = campaign;
  el('#campTitle').textContent = campaign.name || 'Campanha';
  el('#campClient').textContent = campaign.client || '-';
  el('#campPeriod').textContent = campaign.period || '-';

  if (campaignStatusSelect) {
    if (!campaignStatusSelect.options.length) {
      CAMPAIGN_STATUS_OPTIONS.forEach(status => {
        const option = document.createElement('option');
        option.value = status;
        option.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        campaignStatusSelect.appendChild(option);
      });
    }
    const normalizedStatus = normalizeKey(campaign.status || 'ativa');
    const selected = CAMPAIGN_STATUS_OPTIONS.includes(normalizedStatus)
      ? normalizedStatus
      : CAMPAIGN_STATUS_OPTIONS[0];
    campaignStatusSelect.value = selected;
    campaignStatusSelect.dataset.currentValue = selected;
  }

  renderCounts(campaign.counts);

  // KPIs ainda serao refinados quando definirmos regras oficiais
  el('#kpiAd').textContent = metrics.averageAdherence || campaign.adh || '-';
  el('#kpiKm').textContent = formatNumber(metrics.totalKm || 0);
  el('#kpiInst').textContent = campaign.counts?.instalado || 0;
  el('#kpiRev').textContent = campaign.reviewCount || 0;

  const configInfo = el('#configInfo');
  if (configInfo) {
    const infos = [
      campaign.sheetId && `Sheet ID: ${campaign.sheetId}`,
      campaign.sheetName && `Aba: ${campaign.sheetName}`,
      campaign.driveFolderId && `Pasta Drive: ${campaign.driveFolderId}`,
    ].filter(Boolean);
    configInfo.textContent = infos.length ? infos.join(' | ') : configInfo.textContent;
  }

  if (btnSync) {
    const canSync = Boolean(campaign.sheetId);
    btnSync.disabled = !canSync;
    btnSync.title = canSync ? '' : 'Sem planilha vinculada';
  }
}

async function init() {
  if (!campaignId) {
    alert('Campanha nao encontrada (ID ausente).');
    window.location.href = 'index.html';
    return;
  }
  console.debug('init campaignId=', campaignId);
  try {
    const data = await fetchCampaign(campaignId);
    const metrics = calculateMetrics(data.drivers);
    populateSummary(data, metrics);
    renderDrivers(data.drivers);
    renderKm(data.drivers);
    renderReview(data.review);
  } catch (err) {
    console.error('init: failed to load campaign', err);
    const details = [];
    if (err && err.status) details.push(`status=${err.status}`);
    if (err && err.responseText) details.push(err.responseText);
    const msg = `Erro ao carregar detalhes da campanha. ${details.join('\n')}`;
    // show informative alert but don't immediately redirect so we can debug
    alert(msg);
    // leave the page so you can inspect console/network; user can manually return to list
  }
}

function setupTabs() {
  tabs.forEach(tab =>
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      panels.forEach(panel => panel.classList.remove('active'));

      tab.classList.add('active');
      const target = document.getElementById(`tab-${tab.dataset.tab}`);
      if (target) target.classList.add('active');
    }),
  );
}

document.addEventListener('DOMContentLoaded', () => {
  setupTabs();
  init();

  document.addEventListener('click', event => {
    const dismiss = event.target.closest('[data-modal-dismiss]');
    if (dismiss) {
      const modal = dismiss.closest('.modal');
      if (modal) hideModal(modal);
    }
  });

  document.addEventListener('keydown', event => {
    if (event.key === 'Escape') {
      const open = Array.from(document.querySelectorAll('.modal:not(.hidden)'));
      const last = open[open.length - 1];
      if (last) hideModal(last);
    }
  });

  if (btnSaveDrivers) {
    btnSaveDrivers.addEventListener('click', savePendingDriverChanges);
    updateSaveButtonState();
  }

  if (tblDrivers) {
    tblDrivers.addEventListener('click', async event => {
      const nameButton = event.target.closest('.driver-name');
      if (nameButton) {
        const driverId = nameButton.dataset.driverId;
        if (driverId) openDriverDetail(driverId);
        return;
      }

      const deleteButton = event.target.closest('.driver-action-delete');
      if (deleteButton) {
        const driverId = deleteButton.dataset.driverId;
        if (!driverId) return;
        if (!confirm('Deseja excluir este motorista?')) return;

        const original = deleteButton.textContent;
        try {
          deleteButton.disabled = true;
          deleteButton.textContent = 'Excluindo...';
          const res = await fetch(
            `/api/campaigns/${encodeURIComponent(campaignId)}/drivers/${encodeURIComponent(driverId)}`,
            { method: 'DELETE' },
          );
          if (!res.ok) {
            const text = await res.text();
            throw new Error(text || `HTTP ${res.status}`);
          }
          await init();
        } catch (err) {
          console.error(err);
          alert('Nao foi possivel excluir o motorista.');
        } finally {
          if (document.body.contains(deleteButton)) {
            deleteButton.disabled = false;
            deleteButton.textContent = original;
          }
        }
      }
    });
  }

  // KM table click handling (open edit modal)
  const tblKm = document.getElementById('tblKm');
  if (tblKm) {
    tblKm.addEventListener('click', event => {
      const nameButton = event.target.closest('.km-name');
      if (nameButton) {
        const driverId = nameButton.dataset.driverId;
        if (driverId) openKmEdit(driverId);
      }
    });
  }

  const btnSyncKm = document.getElementById('btnSyncKm');
  if (btnSyncKm) {
    btnSyncKm.addEventListener('click', async () => {
      if (!currentCampaign?.kmSheetId && !currentCampaign?.sheetId) {
        alert('Campanha nao possui planilha vinculada para sincronizacao de KM. Primeiro importe a planilha de KM.');
        return;
      }
      const spreadsheetId = currentCampaign.kmSheetId || currentCampaign.sheetId;
      const sheetName = currentCampaign.kmSheetName || currentCampaign.sheetName || 'Planilha1';
      try {
        btnSyncKm.disabled = true;
        btnSyncKm.textContent = 'Sincronizando KM...';
        const res = await fetch('/api/imports/km', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ spreadsheetId, sheetName, campaignId }),
        });
        if (!res.ok) {
          let body;
          try { body = await res.json(); } catch (e) { body = await res.text(); }
          const msg = body && typeof body === 'object' ? `${body.error || ''}\n${body.detail || ''}\n${body.hint || ''}` : String(body || 'Erro');
          throw new Error(msg);
        }
        const result = await res.json();
        alert(`Sincronizacao de KM concluida. Vinculados: ${result.linked} | Revisar: ${result.review}`);
        await init();
      } catch (err) {
        console.error(err);
        alert(String(err.message || err));
      } finally {
        btnSyncKm.disabled = false;
        btnSyncKm.textContent = 'Sincronizar KM';
      }
    });
  }

  const reviewTable = document.getElementById('tblReview');
  if (reviewTable) {
    reviewTable.addEventListener('click', async event => {
      const actionBtn = event.target.closest('[data-review-action]');
      if (!actionBtn) return;
      const reviewId = actionBtn.dataset.reviewId;
      const action = actionBtn.dataset.reviewAction;
      if (!reviewId || !action) return;
      const row = actionBtn.closest('tr');
      if (!row) return;

      if (action === 'apply-status') {
        const select = row.querySelector('.review-status-select');
        if (!select) return;
        const newStatus = select.value;
        if (!newStatus) {
          alert('Selecione um status valido.');
          return;
        }
        const ignoreBtn = row.querySelector('[data-review-action="ignore"]');
        const originalText = actionBtn.textContent;
        actionBtn.disabled = true;
        actionBtn.textContent = 'Aplicando...';
        if (ignoreBtn) ignoreBtn.disabled = true;
        try {
          const res = await fetch(
            `/api/campaigns/${encodeURIComponent(campaignId)}/review/${encodeURIComponent(reviewId)}`,
            {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ status: newStatus }),
            },
          );
          if (!res.ok) {
            const text = await res.text();
            throw new Error(text || `HTTP ${res.status}`);
          }
          await init();
        } catch (err) {
          console.error(err);
          alert('Nao foi possivel aplicar o status.');
          actionBtn.disabled = false;
          actionBtn.textContent = originalText;
          if (ignoreBtn) ignoreBtn.disabled = false;
          return;
        }
        return;
      }

      if (action === 'ignore') {
        if (!confirm('Deseja ignorar este item?')) return;
        actionBtn.disabled = true;
        try {
          const res = await fetch(
            `/api/campaigns/${encodeURIComponent(campaignId)}/review/${encodeURIComponent(reviewId)}`,
            { method: 'DELETE' },
          );
          if (!res.ok) {
            const text = await res.text();
            throw new Error(text || `HTTP ${res.status}`);
          }
          await init();
        } catch (err) {
          console.error(err);
          alert('Nao foi possivel ignorar o item.');
          actionBtn.disabled = false;
        }
      }
    });
  }
  if (btnImportKm) {
    btnImportKm.addEventListener('click', async () => {
      const spreadsheetId = prompt('ID da planilha de KM (Google Sheets):');
      if (!spreadsheetId) return;
      const sheetName = prompt('Nome da aba (padrao Planilha1):', 'Planilha1') || 'Planilha1';

      const payload = {
        spreadsheetId: spreadsheetId.trim(),
        sheetName: sheetName.trim(),
        campaignId,
      };

      const originalLabel = btnImportKm.textContent;
      btnImportKm.disabled = true;
      btnImportKm.textContent = 'Importando...';
      try {
        const res = await fetch('/api/imports/km', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          // try to parse structured JSON error from backend
          let body;
          try {
            body = await res.json();
          } catch (e) {
            body = await res.text();
          }
          const msg = body && typeof body === 'object'
            ? `${body.error || 'Erro'}${body.detail ? '\n' + body.detail : ''}${body.hint ? '\n' + body.hint : ''}`
            : String(body || `HTTP ${res.status}`);
          throw new Error(msg);
        }
        const result = await res.json();
        alert(`Importacao concluida.\nVinculados: ${result.linked}\nItens para revisar: ${result.review}`);
        await init();
      } catch (err) {
        console.error(err);
        alert(String(err.message || err));
      } finally {
        btnImportKm.disabled = false;
        btnImportKm.textContent = originalLabel;
      }
    });
  }

  if (btnAddDriver) {
    btnAddDriver.addEventListener('click', () => {
      if (driverForm) driverForm.reset();
      renderDriverFormFields();
      showModal(driverFormModal);
    });
  }

  if (driverForm) {
    driverForm.addEventListener('submit', async event => {
      event.preventDefault();
      const inputs = driverFormFields
        ? Array.from(driverFormFields.querySelectorAll('[data-column]'))
        : [];
      const fields = {};
      let hasName = false;

      inputs.forEach(input => {
        const column = input.dataset.column;
        if (!column) return;
        const value = input.value.trim();
        if (!hasName && column.toLowerCase() === 'nome' && value) hasName = true;
        if (value) fields[column] = value;
      });

      if (!hasName) {
        alert('Informe o campo Nome.');
        return;
      }

      const originalText = driverFormSubmit ? driverFormSubmit.textContent : '';
      if (driverFormSubmit) {
        driverFormSubmit.disabled = true;
        driverFormSubmit.textContent = 'Salvando...';
      }

      try {
        const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/drivers`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ fields }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        hideModal(driverFormModal);
        if (driverForm) driverForm.reset();
        await init();
        alert('Motorista adicionado com sucesso.');
      } catch (err) {
        console.error(err);
        alert('Nao foi possivel adicionar o motorista.');
      } finally {
        if (driverFormSubmit) {
          driverFormSubmit.disabled = false;
          driverFormSubmit.textContent = originalText || 'Salvar';
        }
      }

      // Create KM manual flow
      const createKmModal = document.getElementById('createKmModal');
      const createKmForm = document.getElementById('createKmForm');
      const createKmDriver = document.getElementById('createKmDriver');
      const createKmNote = document.getElementById('createKmNote');
      const btnSyncKm = document.getElementById('btnSyncKm');

      if (btnCreateKm && createKmModal) {
        btnCreateKm.addEventListener('click', () => {
          // populate driver select with drivers that belong to this campaign
          if (createKmDriver) {
            createKmDriver.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = '-- selecione --';
            createKmDriver.appendChild(placeholder);
            if (Array.isArray(currentCampaign?.drivers)) {
              const collator = new Intl.Collator('pt-BR', { sensitivity: 'base', ignorePunctuation: true });
              const sorted = [...currentCampaign.drivers].sort((a,b) => collator.compare(a.name||'', b.name||''));
              for (const d of sorted) {
                const opt = document.createElement('option');
                opt.value = d.id;
                opt.textContent = d.name || d.raw?.Nome || d.raw?.nome || d.id;
                createKmDriver.appendChild(opt);
              }
            }
          }
          if (createKmNote) createKmNote.value = '';
          console.debug('Opening create KM modal');
          showModal(createKmModal);
        });
      }

      if (createKmForm) {
        createKmForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          const driverId = createKmDriver ? createKmDriver.value : null;
          if (!driverId) return alert('Selecione um motorista.');
          const note = createKmNote ? createKmNote.value.trim() : '';

          try {
            const payload = { fields: {} };
            if (note) payload.fields['COMENTÃRIOS'] = note;

            console.debug('Creating manual KM for driver', driverId, payload);

            const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`, {
              method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload),
            });

            if (!res.ok) {
              let body;
              try { body = await res.json(); } catch (e) { body = await res.text(); }
              console.error('Create KM failed', res.status, body);
              const msg = body && typeof body === 'object' ? `${body.error || ''}\n${body.detail || ''}\n${body.hint || ''}` : String(body || `HTTP ${res.status}`);
              return alert('Falha ao criar KM manual:\n' + msg);
            }

            hideModal(createKmModal);
            await init();
            // open km edit modal for the driver so user can fill remaining fields
            openKmEdit(driverId);
            alert('KM criado (local) com sucesso. Preencha os campos na modal.');
          } catch (err) {
            console.error('Create KM error', err);
            alert('Nao foi possivel criar KM manual. Veja o console para detalhes.');
          }
        });
      } else {
        console.debug('createKmForm not found in DOM');
      }
    });
  }

  if (driverDetailForm) {
    driverDetailForm.addEventListener('submit', async event => {
      event.preventDefault();
      const driverId = driverDetailForm.dataset.driverId;
      const driver = getDriverById(driverId);
      if (!driver) {
        alert('Motorista nao encontrado.');
        return;
      }

      const inputs = driverDetailFields
        ? Array.from(driverDetailFields.querySelectorAll('[data-column]'))
        : [];
      const fields = {};
      inputs.forEach(input => {
        const column = input.dataset.column;
        if (!column) return;
        const value = input.value.trim();
        const original = driver.raw?.[column] ?? '';
        if (value !== original) fields[column] = value;
      });

      if (!Object.keys(fields).length) {
        alert('Nenhuma alteracao realizada.');
        return;
      }

      const originalLabel = driverDetailSubmit ? driverDetailSubmit.textContent : '';
      if (driverDetailSubmit) {
        driverDetailSubmit.disabled = true;
        driverDetailSubmit.textContent = 'Salvando...';
      }

      try {
        const res = await fetch(
          `/api/campaigns/${encodeURIComponent(campaignId)}/drivers/${encodeURIComponent(driverId)}`,
          {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fields }),
          },
        );
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        pendingDriverChanges.delete(driverId);
        markDriverRowDirty(driverId, false);
        hideModal(driverDetailModal);
        await init();
        alert('Motorista atualizado com sucesso.');
      } catch (err) {
        console.error(err);
        alert('Nao foi possivel atualizar o motorista.');
      } finally {
        if (driverDetailSubmit) {
          driverDetailSubmit.disabled = false;
          driverDetailSubmit.textContent = originalLabel || 'Salvar';
        }
      }
    });
  }

  // KM Edit form submit
  const kmEditForm = document.getElementById('kmEditForm');
  const kmEditSubmit = document.getElementById('kmEditSubmit');
  if (kmEditForm) {
    kmEditForm.addEventListener('submit', async event => {
      event.preventDefault();
      const driverId = kmEditForm.dataset.driverId;
      if (!driverId) return alert('Motorista nao identificado.');

      const inputs = Array.from(kmEditForm.querySelectorAll('[data-column]'));
      const fields = {};
      inputs.forEach(input => {
        const col = input.dataset.column;
        if (!col) return;
        const value = input.value.trim();
        const original = input.dataset.originalValue ?? '';
        if (value !== original) fields[col] = value;
      });

      if (!Object.keys(fields).length) {
        alert('Nenhuma alteracao realizada.');
        return;
      }

      const originalLabel = kmEditSubmit ? kmEditSubmit.textContent : '';
      if (kmEditSubmit) {
        kmEditSubmit.disabled = true;
        kmEditSubmit.textContent = 'Salvando...';
      }

      try {
        const res = await fetch(
          `/api/campaigns/${encodeURIComponent(campaignId)}/km/${encodeURIComponent(driverId)}`,
          {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fields }),
          },
        );
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        hideModal(document.getElementById('kmEditModal'));
        await init();
        alert('KM atualizado com sucesso.');
      } catch (err) {
        console.error(err);
        alert('Nao foi possivel salvar o KM.');
      } finally {
        if (kmEditSubmit) {
          kmEditSubmit.disabled = false;
          kmEditSubmit.textContent = originalLabel || 'Salvar KM';
        }
      }
    });
  }

  if (campaignStatusSelect) {
    campaignStatusSelect.addEventListener('change', async () => {
      const selected = campaignStatusSelect.value;
      const original = campaignStatusSelect.dataset.currentValue;
      if (selected === original) return;

      campaignStatusSelect.disabled = true;
      try {
        const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ status: selected }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        campaignStatusSelect.dataset.currentValue = selected;
        if (currentCampaign) currentCampaign.status = selected;
        await init();
        alert('Status da campanha atualizado.');
      } catch (err) {
        console.error(err);
        alert('Nao foi possivel atualizar o status.');
        campaignStatusSelect.value = original;
      } finally {
        campaignStatusSelect.disabled = false;
      }
    });
  }

  if (btnSync) {
    btnSync.addEventListener('click', async () => {
      if (!currentCampaign?.sheetId) {
        alert('Esta campanha nao possui planilha vinculada para sincronizacao.');
        return;
      }
      const original = btnSync.textContent;
      const previousDisabled = btnSync.disabled;
      try {
        btnSync.disabled = true;
        btnSync.textContent = 'Sincronizando...';
        const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}/sync`, {
          method: 'POST',
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        await init();
        alert('Campanha sincronizada com sucesso.');
      } catch (err) {
        console.error(err);
        alert('Nao foi possivel sincronizar a campanha.');
      } finally {
        btnSync.textContent = original;
        btnSync.disabled = previousDisabled ? true : !currentCampaign?.sheetId;
      }
    });
  }

  if (btnDelete) {
    btnDelete.addEventListener('click', async () => {
      if (!confirm('Tem certeza que deseja excluir esta campanha? Essa acao nao pode ser desfeita.')) {
        return;
      }
      const original = btnDelete.textContent;
      try {
        btnDelete.disabled = true;
        btnDelete.textContent = 'Excluindo...';
        const res = await fetch(`/api/campaigns/${encodeURIComponent(campaignId)}`, {
          method: 'DELETE',
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        alert('Campanha excluida.');
        window.location.href = 'index.html';
      } catch (err) {
        console.error(err);
        alert('Nao foi possivel excluir a campanha.');
        btnDelete.disabled = false;
        btnDelete.textContent = original;
      }
    });
  }
});



=== FILE: README.md ===

# OD Drive - Admin

## Requisitos

- Node.js 18 ou superior instalado;
- Credenciais de uma Service Account com acesso ao Google Sheets e ao Drive (compartilhe as planilhas com o e-mail da conta).

## Variaveis de ambiente

Edite `.env` na raiz e preencha:

```
PORT=5173
GOOGLE_CLIENT_EMAIL=seu-service-account@projeto.iam.gserviceaccount.com
GOOGLE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n... \n-----END PRIVATE KEY-----\n"
DRIVE_ROOT_FOLDER_ID=            # opcional
```

> Importante: mantenha as quebras `\n` dentro da chave privada como no exemplo acima.

## Instalacao

```bash
npm install
```

## Execucao

Servidor e frontend (admin) rodando juntos:

```bash
npm start
```

Abra `http://localhost:5173` para acessar a interface do administrador.


Snapshot completed. Files included: 15
Output file: D:\Clientes Agentes\OD Drive\Campanha CHECK\app_oficial_odrive\snapshot_code_20251024_171801.txt
